{"ast":null,"code":"import { CanvasContext } from '../../../../../types/dist/types.js';\nimport { patch, isBlocked, hookSetter } from '../../../utils.js';\nimport { saveWebGLVar, serializeArgs } from './serialize-args.js';\nfunction patchGLPrototype(prototype, type, cb, blockClass, blockSelector, mirror, win) {\n  const handlers = [];\n  const props = Object.getOwnPropertyNames(prototype);\n  for (const prop of props) {\n    if (['isContextLost', 'canvas', 'drawingBufferWidth', 'drawingBufferHeight'].includes(prop)) {\n      continue;\n    }\n    try {\n      if (typeof prototype[prop] !== 'function') {\n        continue;\n      }\n      const restoreHandler = patch(prototype, prop, function (original) {\n        return function (...args) {\n          const result = original.apply(this, args);\n          saveWebGLVar(result, win, this);\n          if (!isBlocked(this.canvas, blockClass, blockSelector, true)) {\n            const recordArgs = serializeArgs([...args], win, this);\n            const mutation = {\n              type,\n              property: prop,\n              args: recordArgs\n            };\n            cb(this.canvas, mutation);\n          }\n          return result;\n        };\n      });\n      handlers.push(restoreHandler);\n    } catch (_a) {\n      const hookHandler = hookSetter(prototype, prop, {\n        set(v) {\n          cb(this.canvas, {\n            type,\n            property: prop,\n            args: [v],\n            setter: true\n          });\n        }\n      });\n      handlers.push(hookHandler);\n    }\n  }\n  return handlers;\n}\nfunction initCanvasWebGLMutationObserver(cb, win, blockClass, blockSelector, mirror) {\n  const handlers = [];\n  handlers.push(...patchGLPrototype(win.WebGLRenderingContext.prototype, CanvasContext.WebGL, cb, blockClass, blockSelector, mirror, win));\n  if (typeof win.WebGL2RenderingContext !== 'undefined') {\n    handlers.push(...patchGLPrototype(win.WebGL2RenderingContext.prototype, CanvasContext.WebGL2, cb, blockClass, blockSelector, mirror, win));\n  }\n  return () => {\n    handlers.forEach(h => h());\n  };\n}\nexport { initCanvasWebGLMutationObserver as default };","map":{"version":3,"names":["CanvasContext","patch","isBlocked","hookSetter","saveWebGLVar","serializeArgs","patchGLPrototype","prototype","type","cb","blockClass","blockSelector","mirror","win","handlers","props","Object","getOwnPropertyNames","prop","includes","restoreHandler","original","args","result","apply","canvas","recordArgs","mutation","property","push","_a","hookHandler","set","v","setter","initCanvasWebGLMutationObserver","WebGLRenderingContext","WebGL","WebGL2RenderingContext","WebGL2","forEach","h","default"],"sources":["/Users/ogonen/rrweb/node_modules/rrweb/es/rrweb/packages/rrweb/src/record/observers/canvas/webgl.js"],"sourcesContent":["import { CanvasContext } from '../../../../../types/dist/types.js';\nimport { patch, isBlocked, hookSetter } from '../../../utils.js';\nimport { saveWebGLVar, serializeArgs } from './serialize-args.js';\n\nfunction patchGLPrototype(prototype, type, cb, blockClass, blockSelector, mirror, win) {\r\n    const handlers = [];\r\n    const props = Object.getOwnPropertyNames(prototype);\r\n    for (const prop of props) {\r\n        if ([\r\n            'isContextLost',\r\n            'canvas',\r\n            'drawingBufferWidth',\r\n            'drawingBufferHeight',\r\n        ].includes(prop)) {\r\n            continue;\r\n        }\r\n        try {\r\n            if (typeof prototype[prop] !== 'function') {\r\n                continue;\r\n            }\r\n            const restoreHandler = patch(prototype, prop, function (original) {\r\n                return function (...args) {\r\n                    const result = original.apply(this, args);\r\n                    saveWebGLVar(result, win, this);\r\n                    if (!isBlocked(this.canvas, blockClass, blockSelector, true)) {\r\n                        const recordArgs = serializeArgs([...args], win, this);\r\n                        const mutation = {\r\n                            type,\r\n                            property: prop,\r\n                            args: recordArgs,\r\n                        };\r\n                        cb(this.canvas, mutation);\r\n                    }\r\n                    return result;\r\n                };\r\n            });\r\n            handlers.push(restoreHandler);\r\n        }\r\n        catch (_a) {\r\n            const hookHandler = hookSetter(prototype, prop, {\r\n                set(v) {\r\n                    cb(this.canvas, {\r\n                        type,\r\n                        property: prop,\r\n                        args: [v],\r\n                        setter: true,\r\n                    });\r\n                },\r\n            });\r\n            handlers.push(hookHandler);\r\n        }\r\n    }\r\n    return handlers;\r\n}\r\nfunction initCanvasWebGLMutationObserver(cb, win, blockClass, blockSelector, mirror) {\r\n    const handlers = [];\r\n    handlers.push(...patchGLPrototype(win.WebGLRenderingContext.prototype, CanvasContext.WebGL, cb, blockClass, blockSelector, mirror, win));\r\n    if (typeof win.WebGL2RenderingContext !== 'undefined') {\r\n        handlers.push(...patchGLPrototype(win.WebGL2RenderingContext.prototype, CanvasContext.WebGL2, cb, blockClass, blockSelector, mirror, win));\r\n    }\r\n    return () => {\r\n        handlers.forEach((h) => h());\r\n    };\r\n}\n\nexport { initCanvasWebGLMutationObserver as default };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}