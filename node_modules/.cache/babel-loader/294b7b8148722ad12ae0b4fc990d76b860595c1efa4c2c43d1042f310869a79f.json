{"ast":null,"code":"// RecordingCutter.js - Utility for cutting rrweb recordings into smaller clips\n\n/**\n * Cuts an rrweb recording to show only events within a specific time range\n * @param {Array} events - Original rrweb events array\n * @param {number} centerTimestamp - The timestamp around which to center the clip\n * @param {number} beforeSeconds - Seconds to include before the center timestamp (default: 5)\n * @param {number} afterSeconds - Seconds to include after the center timestamp (default: 5)\n * @returns {Array} New rrweb events array for the clipped recording\n */\nexport function cutRecording(events, centerTimestamp, beforeSeconds = 5, afterSeconds = 5) {\n  if (!events || !Array.isArray(events) || events.length === 0) {\n    throw new Error(\"Invalid events array provided\");\n  }\n  const beforeMs = beforeSeconds * 1000;\n  const afterMs = afterSeconds * 1000;\n  const startTime = centerTimestamp - beforeMs;\n  const endTime = centerTimestamp + afterMs;\n  console.log(`Cutting recording around timestamp ${centerTimestamp}`);\n  console.log(`Time range: ${startTime} to ${endTime}`);\n\n  // Find the full snapshot (type 2) that's closest to but before our start time\n  let fullSnapshot = null;\n  let fullSnapshotTime = 0;\n  for (const event of events) {\n    if (event.type === 2 && event.timestamp <= startTime) {\n      if (!fullSnapshot || event.timestamp > fullSnapshotTime) {\n        fullSnapshot = event;\n        fullSnapshotTime = event.timestamp;\n      }\n    }\n  }\n\n  // If no full snapshot found before start time, use the first one\n  if (!fullSnapshot) {\n    fullSnapshot = events.find(event => event.type === 2);\n    if (!fullSnapshot) {\n      throw new Error(\"No full snapshot found in recording\");\n    }\n  }\n\n  // Filter events within our time range\n  const clippedEvents = events.filter(event => {\n    return event.timestamp >= startTime && event.timestamp <= endTime;\n  });\n\n  // Create the new events array\n  const newEvents = [];\n\n  // Add the full snapshot at the beginning with adjusted timestamp\n  const adjustedFullSnapshot = {\n    ...fullSnapshot,\n    timestamp: startTime\n  };\n  newEvents.push(adjustedFullSnapshot);\n\n  // Add all events in range, adjusting timestamps to start from the new base time\n  const timeOffset = startTime - fullSnapshotTime;\n  for (const event of clippedEvents) {\n    // Skip if this is the same full snapshot we already added\n    if (event.type === 2 && event.timestamp === fullSnapshot.timestamp) {\n      continue;\n    }\n    const adjustedEvent = {\n      ...event,\n      timestamp: event.timestamp\n    };\n    newEvents.push(adjustedEvent);\n  }\n\n  // Sort by timestamp to ensure proper order\n  newEvents.sort((a, b) => a.timestamp - b.timestamp);\n  console.log(`Original recording: ${events.length} events`);\n  console.log(`Clipped recording: ${newEvents.length} events`);\n  console.log(`Time span: ${(endTime - startTime) / 1000} seconds`);\n  return newEvents;\n}\n\n/**\n * Finds all events of a specific type within a recording\n * @param {Array} events - rrweb events array\n * @param {number} eventType - Event type to search for (1=DOM, 2=FullSnapshot, 3=IncrementalSnapshot, etc.)\n * @returns {Array} Array of events matching the type\n */\nexport function findEventsByType(events, eventType) {\n  return events.filter(event => event.type === eventType);\n}\n\n/**\n * Finds events containing specific text or attributes\n * @param {Array} events - rrweb events array\n * @param {string} searchTerm - Text to search for\n * @returns {Array} Array of events containing the search term\n */\nexport function findEventsByContent(events, searchTerm) {\n  const matchingEvents = [];\n  for (const event of events) {\n    const eventStr = JSON.stringify(event).toLowerCase();\n    if (eventStr.includes(searchTerm.toLowerCase())) {\n      matchingEvents.push(event);\n    }\n  }\n  return matchingEvents;\n}\n\n/**\n * Analyzes a recording and provides statistics\n * @param {Array} events - rrweb events array\n * @returns {Object} Recording statistics\n */\nexport function analyzeRecording(events) {\n  if (!events || !Array.isArray(events) || events.length === 0) {\n    return null;\n  }\n  const firstTimestamp = events[0].timestamp;\n  const lastTimestamp = events[events.length - 1].timestamp;\n  const duration = (lastTimestamp - firstTimestamp) / 1000; // in seconds\n\n  const eventTypeCounts = {};\n  for (const event of events) {\n    eventTypeCounts[event.type] = (eventTypeCounts[event.type] || 0) + 1;\n  }\n  return {\n    totalEvents: events.length,\n    duration: duration,\n    startTime: firstTimestamp,\n    endTime: lastTimestamp,\n    eventTypeCounts: eventTypeCounts,\n    eventTypes: {\n      1: \"DomContentLoaded\",\n      2: \"FullSnapshot\",\n      3: \"IncrementalSnapshot\",\n      4: \"Meta\",\n      5: \"Custom\",\n      6: \"Plugin\"\n    }\n  };\n}\n\n/**\n * Creates multiple clips around specified timestamps\n * @param {Array} events - Original rrweb events array\n * @param {Array} timestamps - Array of timestamps to create clips around\n * @param {number} beforeSeconds - Seconds before each timestamp\n * @param {number} afterSeconds - Seconds after each timestamp\n * @returns {Array} Array of clipped recordings\n */\nexport function createMultipleClips(events, timestamps, beforeSeconds = 5, afterSeconds = 5) {\n  const clips = [];\n  for (let i = 0; i < timestamps.length; i++) {\n    const timestamp = timestamps[i];\n    try {\n      const clip = cutRecording(events, timestamp, beforeSeconds, afterSeconds);\n      clips.push({\n        index: i,\n        centerTimestamp: timestamp,\n        events: clip,\n        duration: beforeSeconds + afterSeconds\n      });\n    } catch (error) {\n      console.error(`Failed to create clip ${i} around timestamp ${timestamp}:`, error);\n    }\n  }\n  return clips;\n}","map":{"version":3,"names":["cutRecording","events","centerTimestamp","beforeSeconds","afterSeconds","Array","isArray","length","Error","beforeMs","afterMs","startTime","endTime","console","log","fullSnapshot","fullSnapshotTime","event","type","timestamp","find","clippedEvents","filter","newEvents","adjustedFullSnapshot","push","timeOffset","adjustedEvent","sort","a","b","findEventsByType","eventType","findEventsByContent","searchTerm","matchingEvents","eventStr","JSON","stringify","toLowerCase","includes","analyzeRecording","firstTimestamp","lastTimestamp","duration","eventTypeCounts","totalEvents","eventTypes","createMultipleClips","timestamps","clips","i","clip","index","error"],"sources":["/Users/ogonen/rrweb/src/RecordingCutter.js"],"sourcesContent":["// RecordingCutter.js - Utility for cutting rrweb recordings into smaller clips\n\n/**\n * Cuts an rrweb recording to show only events within a specific time range\n * @param {Array} events - Original rrweb events array\n * @param {number} centerTimestamp - The timestamp around which to center the clip\n * @param {number} beforeSeconds - Seconds to include before the center timestamp (default: 5)\n * @param {number} afterSeconds - Seconds to include after the center timestamp (default: 5)\n * @returns {Array} New rrweb events array for the clipped recording\n */\nexport function cutRecording(\n  events,\n  centerTimestamp,\n  beforeSeconds = 5,\n  afterSeconds = 5\n) {\n  if (!events || !Array.isArray(events) || events.length === 0) {\n    throw new Error(\"Invalid events array provided\");\n  }\n\n  const beforeMs = beforeSeconds * 1000;\n  const afterMs = afterSeconds * 1000;\n  const startTime = centerTimestamp - beforeMs;\n  const endTime = centerTimestamp + afterMs;\n\n  console.log(`Cutting recording around timestamp ${centerTimestamp}`);\n  console.log(`Time range: ${startTime} to ${endTime}`);\n\n  // Find the full snapshot (type 2) that's closest to but before our start time\n  let fullSnapshot = null;\n  let fullSnapshotTime = 0;\n\n  for (const event of events) {\n    if (event.type === 2 && event.timestamp <= startTime) {\n      if (!fullSnapshot || event.timestamp > fullSnapshotTime) {\n        fullSnapshot = event;\n        fullSnapshotTime = event.timestamp;\n      }\n    }\n  }\n\n  // If no full snapshot found before start time, use the first one\n  if (!fullSnapshot) {\n    fullSnapshot = events.find((event) => event.type === 2);\n    if (!fullSnapshot) {\n      throw new Error(\"No full snapshot found in recording\");\n    }\n  }\n\n  // Filter events within our time range\n  const clippedEvents = events.filter((event) => {\n    return event.timestamp >= startTime && event.timestamp <= endTime;\n  });\n\n  // Create the new events array\n  const newEvents = [];\n\n  // Add the full snapshot at the beginning with adjusted timestamp\n  const adjustedFullSnapshot = {\n    ...fullSnapshot,\n    timestamp: startTime,\n  };\n  newEvents.push(adjustedFullSnapshot);\n\n  // Add all events in range, adjusting timestamps to start from the new base time\n  const timeOffset = startTime - fullSnapshotTime;\n\n  for (const event of clippedEvents) {\n    // Skip if this is the same full snapshot we already added\n    if (event.type === 2 && event.timestamp === fullSnapshot.timestamp) {\n      continue;\n    }\n\n    const adjustedEvent = {\n      ...event,\n      timestamp: event.timestamp,\n    };\n\n    newEvents.push(adjustedEvent);\n  }\n\n  // Sort by timestamp to ensure proper order\n  newEvents.sort((a, b) => a.timestamp - b.timestamp);\n\n  console.log(`Original recording: ${events.length} events`);\n  console.log(`Clipped recording: ${newEvents.length} events`);\n  console.log(`Time span: ${(endTime - startTime) / 1000} seconds`);\n\n  return newEvents;\n}\n\n/**\n * Finds all events of a specific type within a recording\n * @param {Array} events - rrweb events array\n * @param {number} eventType - Event type to search for (1=DOM, 2=FullSnapshot, 3=IncrementalSnapshot, etc.)\n * @returns {Array} Array of events matching the type\n */\nexport function findEventsByType(events, eventType) {\n  return events.filter((event) => event.type === eventType);\n}\n\n/**\n * Finds events containing specific text or attributes\n * @param {Array} events - rrweb events array\n * @param {string} searchTerm - Text to search for\n * @returns {Array} Array of events containing the search term\n */\nexport function findEventsByContent(events, searchTerm) {\n  const matchingEvents = [];\n\n  for (const event of events) {\n    const eventStr = JSON.stringify(event).toLowerCase();\n    if (eventStr.includes(searchTerm.toLowerCase())) {\n      matchingEvents.push(event);\n    }\n  }\n\n  return matchingEvents;\n}\n\n/**\n * Analyzes a recording and provides statistics\n * @param {Array} events - rrweb events array\n * @returns {Object} Recording statistics\n */\nexport function analyzeRecording(events) {\n  if (!events || !Array.isArray(events) || events.length === 0) {\n    return null;\n  }\n\n  const firstTimestamp = events[0].timestamp;\n  const lastTimestamp = events[events.length - 1].timestamp;\n  const duration = (lastTimestamp - firstTimestamp) / 1000; // in seconds\n\n  const eventTypeCounts = {};\n  for (const event of events) {\n    eventTypeCounts[event.type] = (eventTypeCounts[event.type] || 0) + 1;\n  }\n\n  return {\n    totalEvents: events.length,\n    duration: duration,\n    startTime: firstTimestamp,\n    endTime: lastTimestamp,\n    eventTypeCounts: eventTypeCounts,\n    eventTypes: {\n      1: \"DomContentLoaded\",\n      2: \"FullSnapshot\",\n      3: \"IncrementalSnapshot\",\n      4: \"Meta\",\n      5: \"Custom\",\n      6: \"Plugin\",\n    },\n  };\n}\n\n/**\n * Creates multiple clips around specified timestamps\n * @param {Array} events - Original rrweb events array\n * @param {Array} timestamps - Array of timestamps to create clips around\n * @param {number} beforeSeconds - Seconds before each timestamp\n * @param {number} afterSeconds - Seconds after each timestamp\n * @returns {Array} Array of clipped recordings\n */\nexport function createMultipleClips(\n  events,\n  timestamps,\n  beforeSeconds = 5,\n  afterSeconds = 5\n) {\n  const clips = [];\n\n  for (let i = 0; i < timestamps.length; i++) {\n    const timestamp = timestamps[i];\n    try {\n      const clip = cutRecording(events, timestamp, beforeSeconds, afterSeconds);\n      clips.push({\n        index: i,\n        centerTimestamp: timestamp,\n        events: clip,\n        duration: beforeSeconds + afterSeconds,\n      });\n    } catch (error) {\n      console.error(\n        `Failed to create clip ${i} around timestamp ${timestamp}:`,\n        error\n      );\n    }\n  }\n\n  return clips;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}