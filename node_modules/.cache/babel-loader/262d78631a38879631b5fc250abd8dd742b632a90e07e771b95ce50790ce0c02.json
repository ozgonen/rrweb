{"ast":null,"code":"import { __rest, __awaiter } from './../../../../../../ext/tslib/tslib.es6.js';\nimport { isBlocked } from '../../../utils.js';\nimport { CanvasContext } from '../../../../../types/dist/types.js';\nimport initCanvas2DMutationObserver from './2d.js';\nimport initCanvasContextObserver from './canvas.js';\nimport initCanvasWebGLMutationObserver from './webgl.js';\nimport WorkerFactory from '../../../../../../_virtual/image-bitmap-data-url-worker.js';\nclass CanvasManager {\n  constructor(options) {\n    this.pendingCanvasMutations = new Map();\n    this.rafStamps = {\n      latestId: 0,\n      invokeId: null\n    };\n    this.frozen = false;\n    this.locked = false;\n    this.processMutation = (target, mutation) => {\n      const newFrame = this.rafStamps.invokeId && this.rafStamps.latestId !== this.rafStamps.invokeId;\n      if (newFrame || !this.rafStamps.invokeId) this.rafStamps.invokeId = this.rafStamps.latestId;\n      if (!this.pendingCanvasMutations.has(target)) {\n        this.pendingCanvasMutations.set(target, []);\n      }\n      this.pendingCanvasMutations.get(target).push(mutation);\n    };\n    const {\n      sampling = 'all',\n      win,\n      blockClass,\n      blockSelector,\n      recordCanvas,\n      dataURLOptions\n    } = options;\n    this.mutationCb = options.mutationCb;\n    this.mirror = options.mirror;\n    if (recordCanvas && sampling === 'all') this.initCanvasMutationObserver(win, blockClass, blockSelector);\n    if (recordCanvas && typeof sampling === 'number') this.initCanvasFPSObserver(sampling, win, blockClass, blockSelector, {\n      dataURLOptions\n    });\n  }\n  reset() {\n    this.pendingCanvasMutations.clear();\n    this.resetObservers && this.resetObservers();\n  }\n  freeze() {\n    this.frozen = true;\n  }\n  unfreeze() {\n    this.frozen = false;\n  }\n  lock() {\n    this.locked = true;\n  }\n  unlock() {\n    this.locked = false;\n  }\n  initCanvasFPSObserver(fps, win, blockClass, blockSelector, options) {\n    const canvasContextReset = initCanvasContextObserver(win, blockClass, blockSelector);\n    const snapshotInProgressMap = new Map();\n    const worker = new WorkerFactory();\n    worker.onmessage = e => {\n      const {\n        id\n      } = e.data;\n      snapshotInProgressMap.set(id, false);\n      if (!('base64' in e.data)) return;\n      const {\n        base64,\n        type,\n        width,\n        height\n      } = e.data;\n      this.mutationCb({\n        id,\n        type: CanvasContext['2D'],\n        commands: [{\n          property: 'clearRect',\n          args: [0, 0, width, height]\n        }, {\n          property: 'drawImage',\n          args: [{\n            rr_type: 'ImageBitmap',\n            args: [{\n              rr_type: 'Blob',\n              data: [{\n                rr_type: 'ArrayBuffer',\n                base64\n              }],\n              type\n            }]\n          }, 0, 0]\n        }]\n      });\n    };\n    const timeBetweenSnapshots = 1000 / fps;\n    let lastSnapshotTime = 0;\n    let rafId;\n    const getCanvas = () => {\n      const matchedCanvas = [];\n      win.document.querySelectorAll('canvas').forEach(canvas => {\n        if (!isBlocked(canvas, blockClass, blockSelector, true)) {\n          matchedCanvas.push(canvas);\n        }\n      });\n      return matchedCanvas;\n    };\n    const takeCanvasSnapshots = timestamp => {\n      if (lastSnapshotTime && timestamp - lastSnapshotTime < timeBetweenSnapshots) {\n        rafId = requestAnimationFrame(takeCanvasSnapshots);\n        return;\n      }\n      lastSnapshotTime = timestamp;\n      getCanvas().forEach(canvas => __awaiter(this, void 0, void 0, function* () {\n        var _a;\n        const id = this.mirror.getId(canvas);\n        if (snapshotInProgressMap.get(id)) return;\n        snapshotInProgressMap.set(id, true);\n        if (['webgl', 'webgl2'].includes(canvas.__context)) {\n          const context = canvas.getContext(canvas.__context);\n          if (((_a = context === null || context === void 0 ? void 0 : context.getContextAttributes()) === null || _a === void 0 ? void 0 : _a.preserveDrawingBuffer) === false) {\n            context === null || context === void 0 ? void 0 : context.clear(context.COLOR_BUFFER_BIT);\n          }\n        }\n        const bitmap = yield createImageBitmap(canvas);\n        worker.postMessage({\n          id,\n          bitmap,\n          width: canvas.width,\n          height: canvas.height,\n          dataURLOptions: options.dataURLOptions\n        }, [bitmap]);\n      }));\n      rafId = requestAnimationFrame(takeCanvasSnapshots);\n    };\n    rafId = requestAnimationFrame(takeCanvasSnapshots);\n    this.resetObservers = () => {\n      canvasContextReset();\n      cancelAnimationFrame(rafId);\n    };\n  }\n  initCanvasMutationObserver(win, blockClass, blockSelector) {\n    this.startRAFTimestamping();\n    this.startPendingCanvasMutationFlusher();\n    const canvasContextReset = initCanvasContextObserver(win, blockClass, blockSelector);\n    const canvas2DReset = initCanvas2DMutationObserver(this.processMutation.bind(this), win, blockClass, blockSelector);\n    const canvasWebGL1and2Reset = initCanvasWebGLMutationObserver(this.processMutation.bind(this), win, blockClass, blockSelector, this.mirror);\n    this.resetObservers = () => {\n      canvasContextReset();\n      canvas2DReset();\n      canvasWebGL1and2Reset();\n    };\n  }\n  startPendingCanvasMutationFlusher() {\n    requestAnimationFrame(() => this.flushPendingCanvasMutations());\n  }\n  startRAFTimestamping() {\n    const setLatestRAFTimestamp = timestamp => {\n      this.rafStamps.latestId = timestamp;\n      requestAnimationFrame(setLatestRAFTimestamp);\n    };\n    requestAnimationFrame(setLatestRAFTimestamp);\n  }\n  flushPendingCanvasMutations() {\n    this.pendingCanvasMutations.forEach((values, canvas) => {\n      const id = this.mirror.getId(canvas);\n      this.flushPendingCanvasMutationFor(canvas, id);\n    });\n    requestAnimationFrame(() => this.flushPendingCanvasMutations());\n  }\n  flushPendingCanvasMutationFor(canvas, id) {\n    if (this.frozen || this.locked) {\n      return;\n    }\n    const valuesWithType = this.pendingCanvasMutations.get(canvas);\n    if (!valuesWithType || id === -1) return;\n    const values = valuesWithType.map(value => {\n      const rest = __rest(value, [\"type\"]);\n      return rest;\n    });\n    const {\n      type\n    } = valuesWithType[0];\n    this.mutationCb({\n      id,\n      type,\n      commands: values\n    });\n    this.pendingCanvasMutations.delete(canvas);\n  }\n}\nexport { CanvasManager };","map":{"version":3,"names":["__rest","__awaiter","isBlocked","CanvasContext","initCanvas2DMutationObserver","initCanvasContextObserver","initCanvasWebGLMutationObserver","WorkerFactory","CanvasManager","constructor","options","pendingCanvasMutations","Map","rafStamps","latestId","invokeId","frozen","locked","processMutation","target","mutation","newFrame","has","set","get","push","sampling","win","blockClass","blockSelector","recordCanvas","dataURLOptions","mutationCb","mirror","initCanvasMutationObserver","initCanvasFPSObserver","reset","clear","resetObservers","freeze","unfreeze","lock","unlock","fps","canvasContextReset","snapshotInProgressMap","worker","onmessage","e","id","data","base64","type","width","height","commands","property","args","rr_type","timeBetweenSnapshots","lastSnapshotTime","rafId","getCanvas","matchedCanvas","document","querySelectorAll","forEach","canvas","takeCanvasSnapshots","timestamp","requestAnimationFrame","_a","getId","includes","__context","context","getContext","getContextAttributes","preserveDrawingBuffer","COLOR_BUFFER_BIT","bitmap","createImageBitmap","postMessage","cancelAnimationFrame","startRAFTimestamping","startPendingCanvasMutationFlusher","canvas2DReset","bind","canvasWebGL1and2Reset","flushPendingCanvasMutations","setLatestRAFTimestamp","values","flushPendingCanvasMutationFor","valuesWithType","map","value","rest","delete"],"sources":["/Users/ogonen/rrweb/node_modules/rrweb/es/rrweb/packages/rrweb/src/record/observers/canvas/canvas-manager.js"],"sourcesContent":["import { __rest, __awaiter } from './../../../../../../ext/tslib/tslib.es6.js';\nimport { isBlocked } from '../../../utils.js';\nimport { CanvasContext } from '../../../../../types/dist/types.js';\nimport initCanvas2DMutationObserver from './2d.js';\nimport initCanvasContextObserver from './canvas.js';\nimport initCanvasWebGLMutationObserver from './webgl.js';\nimport WorkerFactory from '../../../../../../_virtual/image-bitmap-data-url-worker.js';\n\nclass CanvasManager {\r\n    constructor(options) {\r\n        this.pendingCanvasMutations = new Map();\r\n        this.rafStamps = { latestId: 0, invokeId: null };\r\n        this.frozen = false;\r\n        this.locked = false;\r\n        this.processMutation = (target, mutation) => {\r\n            const newFrame = this.rafStamps.invokeId &&\r\n                this.rafStamps.latestId !== this.rafStamps.invokeId;\r\n            if (newFrame || !this.rafStamps.invokeId)\r\n                this.rafStamps.invokeId = this.rafStamps.latestId;\r\n            if (!this.pendingCanvasMutations.has(target)) {\r\n                this.pendingCanvasMutations.set(target, []);\r\n            }\r\n            this.pendingCanvasMutations.get(target).push(mutation);\r\n        };\r\n        const { sampling = 'all', win, blockClass, blockSelector, recordCanvas, dataURLOptions, } = options;\r\n        this.mutationCb = options.mutationCb;\r\n        this.mirror = options.mirror;\r\n        if (recordCanvas && sampling === 'all')\r\n            this.initCanvasMutationObserver(win, blockClass, blockSelector);\r\n        if (recordCanvas && typeof sampling === 'number')\r\n            this.initCanvasFPSObserver(sampling, win, blockClass, blockSelector, {\r\n                dataURLOptions,\r\n            });\r\n    }\r\n    reset() {\r\n        this.pendingCanvasMutations.clear();\r\n        this.resetObservers && this.resetObservers();\r\n    }\r\n    freeze() {\r\n        this.frozen = true;\r\n    }\r\n    unfreeze() {\r\n        this.frozen = false;\r\n    }\r\n    lock() {\r\n        this.locked = true;\r\n    }\r\n    unlock() {\r\n        this.locked = false;\r\n    }\r\n    initCanvasFPSObserver(fps, win, blockClass, blockSelector, options) {\r\n        const canvasContextReset = initCanvasContextObserver(win, blockClass, blockSelector);\r\n        const snapshotInProgressMap = new Map();\r\n        const worker = new WorkerFactory();\r\n        worker.onmessage = (e) => {\r\n            const { id } = e.data;\r\n            snapshotInProgressMap.set(id, false);\r\n            if (!('base64' in e.data))\r\n                return;\r\n            const { base64, type, width, height } = e.data;\r\n            this.mutationCb({\r\n                id,\r\n                type: CanvasContext['2D'],\r\n                commands: [\r\n                    {\r\n                        property: 'clearRect',\r\n                        args: [0, 0, width, height],\r\n                    },\r\n                    {\r\n                        property: 'drawImage',\r\n                        args: [\r\n                            {\r\n                                rr_type: 'ImageBitmap',\r\n                                args: [\r\n                                    {\r\n                                        rr_type: 'Blob',\r\n                                        data: [{ rr_type: 'ArrayBuffer', base64 }],\r\n                                        type,\r\n                                    },\r\n                                ],\r\n                            },\r\n                            0,\r\n                            0,\r\n                        ],\r\n                    },\r\n                ],\r\n            });\r\n        };\r\n        const timeBetweenSnapshots = 1000 / fps;\r\n        let lastSnapshotTime = 0;\r\n        let rafId;\r\n        const getCanvas = () => {\r\n            const matchedCanvas = [];\r\n            win.document.querySelectorAll('canvas').forEach((canvas) => {\r\n                if (!isBlocked(canvas, blockClass, blockSelector, true)) {\r\n                    matchedCanvas.push(canvas);\r\n                }\r\n            });\r\n            return matchedCanvas;\r\n        };\r\n        const takeCanvasSnapshots = (timestamp) => {\r\n            if (lastSnapshotTime &&\r\n                timestamp - lastSnapshotTime < timeBetweenSnapshots) {\r\n                rafId = requestAnimationFrame(takeCanvasSnapshots);\r\n                return;\r\n            }\r\n            lastSnapshotTime = timestamp;\r\n            getCanvas()\r\n                .forEach((canvas) => __awaiter(this, void 0, void 0, function* () {\r\n                var _a;\r\n                const id = this.mirror.getId(canvas);\r\n                if (snapshotInProgressMap.get(id))\r\n                    return;\r\n                snapshotInProgressMap.set(id, true);\r\n                if (['webgl', 'webgl2'].includes(canvas.__context)) {\r\n                    const context = canvas.getContext(canvas.__context);\r\n                    if (((_a = context === null || context === void 0 ? void 0 : context.getContextAttributes()) === null || _a === void 0 ? void 0 : _a.preserveDrawingBuffer) === false) {\r\n                        context === null || context === void 0 ? void 0 : context.clear(context.COLOR_BUFFER_BIT);\r\n                    }\r\n                }\r\n                const bitmap = yield createImageBitmap(canvas);\r\n                worker.postMessage({\r\n                    id,\r\n                    bitmap,\r\n                    width: canvas.width,\r\n                    height: canvas.height,\r\n                    dataURLOptions: options.dataURLOptions,\r\n                }, [bitmap]);\r\n            }));\r\n            rafId = requestAnimationFrame(takeCanvasSnapshots);\r\n        };\r\n        rafId = requestAnimationFrame(takeCanvasSnapshots);\r\n        this.resetObservers = () => {\r\n            canvasContextReset();\r\n            cancelAnimationFrame(rafId);\r\n        };\r\n    }\r\n    initCanvasMutationObserver(win, blockClass, blockSelector) {\r\n        this.startRAFTimestamping();\r\n        this.startPendingCanvasMutationFlusher();\r\n        const canvasContextReset = initCanvasContextObserver(win, blockClass, blockSelector);\r\n        const canvas2DReset = initCanvas2DMutationObserver(this.processMutation.bind(this), win, blockClass, blockSelector);\r\n        const canvasWebGL1and2Reset = initCanvasWebGLMutationObserver(this.processMutation.bind(this), win, blockClass, blockSelector, this.mirror);\r\n        this.resetObservers = () => {\r\n            canvasContextReset();\r\n            canvas2DReset();\r\n            canvasWebGL1and2Reset();\r\n        };\r\n    }\r\n    startPendingCanvasMutationFlusher() {\r\n        requestAnimationFrame(() => this.flushPendingCanvasMutations());\r\n    }\r\n    startRAFTimestamping() {\r\n        const setLatestRAFTimestamp = (timestamp) => {\r\n            this.rafStamps.latestId = timestamp;\r\n            requestAnimationFrame(setLatestRAFTimestamp);\r\n        };\r\n        requestAnimationFrame(setLatestRAFTimestamp);\r\n    }\r\n    flushPendingCanvasMutations() {\r\n        this.pendingCanvasMutations.forEach((values, canvas) => {\r\n            const id = this.mirror.getId(canvas);\r\n            this.flushPendingCanvasMutationFor(canvas, id);\r\n        });\r\n        requestAnimationFrame(() => this.flushPendingCanvasMutations());\r\n    }\r\n    flushPendingCanvasMutationFor(canvas, id) {\r\n        if (this.frozen || this.locked) {\r\n            return;\r\n        }\r\n        const valuesWithType = this.pendingCanvasMutations.get(canvas);\r\n        if (!valuesWithType || id === -1)\r\n            return;\r\n        const values = valuesWithType.map((value) => {\r\n            const rest = __rest(value, [\"type\"]);\r\n            return rest;\r\n        });\r\n        const { type } = valuesWithType[0];\r\n        this.mutationCb({ id, type, commands: values });\r\n        this.pendingCanvasMutations.delete(canvas);\r\n    }\r\n}\n\nexport { CanvasManager };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}