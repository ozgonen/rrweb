{"ast":null,"code":"import { interpret as v, createMachine as s, assign as o } from './../../../../ext/@xstate/fsm/es/index.js';\nimport { EventType, IncrementalSource, ReplayerEvents } from '../../../types/dist/types.js';\nimport { addDelay } from './timer.js';\nfunction discardPriorSnapshots(events, baselineTime) {\n  for (let idx = events.length - 1; idx >= 0; idx--) {\n    const event = events[idx];\n    if (event.type === EventType.Meta) {\n      if (event.timestamp <= baselineTime) {\n        return events.slice(idx);\n      }\n    }\n  }\n  return events;\n}\nfunction createPlayerService(context, {\n  getCastFn,\n  applyEventsSynchronously,\n  emitter\n}) {\n  const playerMachine = s({\n    id: 'player',\n    context,\n    initial: 'paused',\n    states: {\n      playing: {\n        on: {\n          PAUSE: {\n            target: 'paused',\n            actions: ['pause']\n          },\n          CAST_EVENT: {\n            target: 'playing',\n            actions: 'castEvent'\n          },\n          END: {\n            target: 'paused',\n            actions: ['resetLastPlayedEvent', 'pause']\n          },\n          ADD_EVENT: {\n            target: 'playing',\n            actions: ['addEvent']\n          }\n        }\n      },\n      paused: {\n        on: {\n          PLAY: {\n            target: 'playing',\n            actions: ['recordTimeOffset', 'play']\n          },\n          CAST_EVENT: {\n            target: 'paused',\n            actions: 'castEvent'\n          },\n          TO_LIVE: {\n            target: 'live',\n            actions: ['startLive']\n          },\n          ADD_EVENT: {\n            target: 'paused',\n            actions: ['addEvent']\n          }\n        }\n      },\n      live: {\n        on: {\n          ADD_EVENT: {\n            target: 'live',\n            actions: ['addEvent']\n          },\n          CAST_EVENT: {\n            target: 'live',\n            actions: ['castEvent']\n          }\n        }\n      }\n    }\n  }, {\n    actions: {\n      castEvent: o({\n        lastPlayedEvent: (ctx, event) => {\n          if (event.type === 'CAST_EVENT') {\n            return event.payload.event;\n          }\n          return ctx.lastPlayedEvent;\n        }\n      }),\n      recordTimeOffset: o((ctx, event) => {\n        let timeOffset = ctx.timeOffset;\n        if ('payload' in event && 'timeOffset' in event.payload) {\n          timeOffset = event.payload.timeOffset;\n        }\n        return Object.assign(Object.assign({}, ctx), {\n          timeOffset,\n          baselineTime: ctx.events[0].timestamp + timeOffset\n        });\n      }),\n      play(ctx) {\n        var _a;\n        const {\n          timer,\n          events,\n          baselineTime,\n          lastPlayedEvent\n        } = ctx;\n        timer.clear();\n        for (const event of events) {\n          addDelay(event, baselineTime);\n        }\n        const neededEvents = discardPriorSnapshots(events, baselineTime);\n        let lastPlayedTimestamp = lastPlayedEvent === null || lastPlayedEvent === void 0 ? void 0 : lastPlayedEvent.timestamp;\n        if ((lastPlayedEvent === null || lastPlayedEvent === void 0 ? void 0 : lastPlayedEvent.type) === EventType.IncrementalSnapshot && lastPlayedEvent.data.source === IncrementalSource.MouseMove) {\n          lastPlayedTimestamp = lastPlayedEvent.timestamp + ((_a = lastPlayedEvent.data.positions[0]) === null || _a === void 0 ? void 0 : _a.timeOffset);\n        }\n        if (baselineTime < (lastPlayedTimestamp || 0)) {\n          emitter.emit(ReplayerEvents.PlayBack);\n        }\n        const syncEvents = new Array();\n        for (const event of neededEvents) {\n          if (lastPlayedTimestamp && lastPlayedTimestamp < baselineTime && (event.timestamp <= lastPlayedTimestamp || event === lastPlayedEvent)) {\n            continue;\n          }\n          if (event.timestamp < baselineTime) {\n            syncEvents.push(event);\n          } else {\n            const castFn = getCastFn(event, false);\n            timer.addAction({\n              doAction: () => {\n                castFn();\n              },\n              delay: event.delay\n            });\n          }\n        }\n        applyEventsSynchronously(syncEvents);\n        emitter.emit(ReplayerEvents.Flush);\n        timer.start();\n      },\n      pause(ctx) {\n        ctx.timer.clear();\n      },\n      resetLastPlayedEvent: o(ctx => {\n        return Object.assign(Object.assign({}, ctx), {\n          lastPlayedEvent: null\n        });\n      }),\n      startLive: o({\n        baselineTime: (ctx, event) => {\n          ctx.timer.toggleLiveMode(true);\n          ctx.timer.start();\n          if (event.type === 'TO_LIVE' && event.payload.baselineTime) {\n            return event.payload.baselineTime;\n          }\n          return Date.now();\n        }\n      }),\n      addEvent: o((ctx, machineEvent) => {\n        const {\n          baselineTime,\n          timer,\n          events\n        } = ctx;\n        if (machineEvent.type === 'ADD_EVENT') {\n          const {\n            event\n          } = machineEvent.payload;\n          addDelay(event, baselineTime);\n          let end = events.length - 1;\n          if (!events[end] || events[end].timestamp <= event.timestamp) {\n            events.push(event);\n          } else {\n            let insertionIndex = -1;\n            let start = 0;\n            while (start <= end) {\n              const mid = Math.floor((start + end) / 2);\n              if (events[mid].timestamp <= event.timestamp) {\n                start = mid + 1;\n              } else {\n                end = mid - 1;\n              }\n            }\n            if (insertionIndex === -1) {\n              insertionIndex = start;\n            }\n            events.splice(insertionIndex, 0, event);\n          }\n          const isSync = event.timestamp < baselineTime;\n          const castFn = getCastFn(event, isSync);\n          if (isSync) {\n            castFn();\n          } else if (timer.isActive()) {\n            timer.addAction({\n              doAction: () => {\n                castFn();\n              },\n              delay: event.delay\n            });\n          }\n        }\n        return Object.assign(Object.assign({}, ctx), {\n          events\n        });\n      })\n    }\n  });\n  return v(playerMachine);\n}\nfunction createSpeedService(context) {\n  const speedMachine = s({\n    id: 'speed',\n    context,\n    initial: 'normal',\n    states: {\n      normal: {\n        on: {\n          FAST_FORWARD: {\n            target: 'skipping',\n            actions: ['recordSpeed', 'setSpeed']\n          },\n          SET_SPEED: {\n            target: 'normal',\n            actions: ['setSpeed']\n          }\n        }\n      },\n      skipping: {\n        on: {\n          BACK_TO_NORMAL: {\n            target: 'normal',\n            actions: ['restoreSpeed']\n          },\n          SET_SPEED: {\n            target: 'normal',\n            actions: ['setSpeed']\n          }\n        }\n      }\n    }\n  }, {\n    actions: {\n      setSpeed: (ctx, event) => {\n        if ('payload' in event) {\n          ctx.timer.setSpeed(event.payload.speed);\n        }\n      },\n      recordSpeed: o({\n        normalSpeed: ctx => ctx.timer.speed\n      }),\n      restoreSpeed: ctx => {\n        ctx.timer.setSpeed(ctx.normalSpeed);\n      }\n    }\n  });\n  return v(speedMachine);\n}\nexport { createPlayerService, createSpeedService, discardPriorSnapshots };","map":{"version":3,"names":["interpret","v","createMachine","s","assign","o","EventType","IncrementalSource","ReplayerEvents","addDelay","discardPriorSnapshots","events","baselineTime","idx","length","event","type","Meta","timestamp","slice","createPlayerService","context","getCastFn","applyEventsSynchronously","emitter","playerMachine","id","initial","states","playing","on","PAUSE","target","actions","CAST_EVENT","END","ADD_EVENT","paused","PLAY","TO_LIVE","live","castEvent","lastPlayedEvent","ctx","payload","recordTimeOffset","timeOffset","Object","play","_a","timer","clear","neededEvents","lastPlayedTimestamp","IncrementalSnapshot","data","source","MouseMove","positions","emit","PlayBack","syncEvents","Array","push","castFn","addAction","doAction","delay","Flush","start","pause","resetLastPlayedEvent","startLive","toggleLiveMode","Date","now","addEvent","machineEvent","end","insertionIndex","mid","Math","floor","splice","isSync","isActive","createSpeedService","speedMachine","normal","FAST_FORWARD","SET_SPEED","skipping","BACK_TO_NORMAL","setSpeed","speed","recordSpeed","normalSpeed","restoreSpeed"],"sources":["/Users/ogonen/rrweb/node_modules/rrweb/es/rrweb/packages/rrweb/src/replay/machine.js"],"sourcesContent":["import { interpret as v, createMachine as s, assign as o } from './../../../../ext/@xstate/fsm/es/index.js';\nimport { EventType, IncrementalSource, ReplayerEvents } from '../../../types/dist/types.js';\nimport { addDelay } from './timer.js';\n\nfunction discardPriorSnapshots(events, baselineTime) {\r\n    for (let idx = events.length - 1; idx >= 0; idx--) {\r\n        const event = events[idx];\r\n        if (event.type === EventType.Meta) {\r\n            if (event.timestamp <= baselineTime) {\r\n                return events.slice(idx);\r\n            }\r\n        }\r\n    }\r\n    return events;\r\n}\r\nfunction createPlayerService(context, { getCastFn, applyEventsSynchronously, emitter }) {\r\n    const playerMachine = s({\r\n        id: 'player',\r\n        context,\r\n        initial: 'paused',\r\n        states: {\r\n            playing: {\r\n                on: {\r\n                    PAUSE: {\r\n                        target: 'paused',\r\n                        actions: ['pause'],\r\n                    },\r\n                    CAST_EVENT: {\r\n                        target: 'playing',\r\n                        actions: 'castEvent',\r\n                    },\r\n                    END: {\r\n                        target: 'paused',\r\n                        actions: ['resetLastPlayedEvent', 'pause'],\r\n                    },\r\n                    ADD_EVENT: {\r\n                        target: 'playing',\r\n                        actions: ['addEvent'],\r\n                    },\r\n                },\r\n            },\r\n            paused: {\r\n                on: {\r\n                    PLAY: {\r\n                        target: 'playing',\r\n                        actions: ['recordTimeOffset', 'play'],\r\n                    },\r\n                    CAST_EVENT: {\r\n                        target: 'paused',\r\n                        actions: 'castEvent',\r\n                    },\r\n                    TO_LIVE: {\r\n                        target: 'live',\r\n                        actions: ['startLive'],\r\n                    },\r\n                    ADD_EVENT: {\r\n                        target: 'paused',\r\n                        actions: ['addEvent'],\r\n                    },\r\n                },\r\n            },\r\n            live: {\r\n                on: {\r\n                    ADD_EVENT: {\r\n                        target: 'live',\r\n                        actions: ['addEvent'],\r\n                    },\r\n                    CAST_EVENT: {\r\n                        target: 'live',\r\n                        actions: ['castEvent'],\r\n                    },\r\n                },\r\n            },\r\n        },\r\n    }, {\r\n        actions: {\r\n            castEvent: o({\r\n                lastPlayedEvent: (ctx, event) => {\r\n                    if (event.type === 'CAST_EVENT') {\r\n                        return event.payload.event;\r\n                    }\r\n                    return ctx.lastPlayedEvent;\r\n                },\r\n            }),\r\n            recordTimeOffset: o((ctx, event) => {\r\n                let timeOffset = ctx.timeOffset;\r\n                if ('payload' in event && 'timeOffset' in event.payload) {\r\n                    timeOffset = event.payload.timeOffset;\r\n                }\r\n                return Object.assign(Object.assign({}, ctx), { timeOffset, baselineTime: ctx.events[0].timestamp + timeOffset });\r\n            }),\r\n            play(ctx) {\r\n                var _a;\r\n                const { timer, events, baselineTime, lastPlayedEvent } = ctx;\r\n                timer.clear();\r\n                for (const event of events) {\r\n                    addDelay(event, baselineTime);\r\n                }\r\n                const neededEvents = discardPriorSnapshots(events, baselineTime);\r\n                let lastPlayedTimestamp = lastPlayedEvent === null || lastPlayedEvent === void 0 ? void 0 : lastPlayedEvent.timestamp;\r\n                if ((lastPlayedEvent === null || lastPlayedEvent === void 0 ? void 0 : lastPlayedEvent.type) === EventType.IncrementalSnapshot &&\r\n                    lastPlayedEvent.data.source === IncrementalSource.MouseMove) {\r\n                    lastPlayedTimestamp =\r\n                        lastPlayedEvent.timestamp +\r\n                            ((_a = lastPlayedEvent.data.positions[0]) === null || _a === void 0 ? void 0 : _a.timeOffset);\r\n                }\r\n                if (baselineTime < (lastPlayedTimestamp || 0)) {\r\n                    emitter.emit(ReplayerEvents.PlayBack);\r\n                }\r\n                const syncEvents = new Array();\r\n                for (const event of neededEvents) {\r\n                    if (lastPlayedTimestamp &&\r\n                        lastPlayedTimestamp < baselineTime &&\r\n                        (event.timestamp <= lastPlayedTimestamp ||\r\n                            event === lastPlayedEvent)) {\r\n                        continue;\r\n                    }\r\n                    if (event.timestamp < baselineTime) {\r\n                        syncEvents.push(event);\r\n                    }\r\n                    else {\r\n                        const castFn = getCastFn(event, false);\r\n                        timer.addAction({\r\n                            doAction: () => {\r\n                                castFn();\r\n                            },\r\n                            delay: event.delay,\r\n                        });\r\n                    }\r\n                }\r\n                applyEventsSynchronously(syncEvents);\r\n                emitter.emit(ReplayerEvents.Flush);\r\n                timer.start();\r\n            },\r\n            pause(ctx) {\r\n                ctx.timer.clear();\r\n            },\r\n            resetLastPlayedEvent: o((ctx) => {\r\n                return Object.assign(Object.assign({}, ctx), { lastPlayedEvent: null });\r\n            }),\r\n            startLive: o({\r\n                baselineTime: (ctx, event) => {\r\n                    ctx.timer.toggleLiveMode(true);\r\n                    ctx.timer.start();\r\n                    if (event.type === 'TO_LIVE' && event.payload.baselineTime) {\r\n                        return event.payload.baselineTime;\r\n                    }\r\n                    return Date.now();\r\n                },\r\n            }),\r\n            addEvent: o((ctx, machineEvent) => {\r\n                const { baselineTime, timer, events } = ctx;\r\n                if (machineEvent.type === 'ADD_EVENT') {\r\n                    const { event } = machineEvent.payload;\r\n                    addDelay(event, baselineTime);\r\n                    let end = events.length - 1;\r\n                    if (!events[end] || events[end].timestamp <= event.timestamp) {\r\n                        events.push(event);\r\n                    }\r\n                    else {\r\n                        let insertionIndex = -1;\r\n                        let start = 0;\r\n                        while (start <= end) {\r\n                            const mid = Math.floor((start + end) / 2);\r\n                            if (events[mid].timestamp <= event.timestamp) {\r\n                                start = mid + 1;\r\n                            }\r\n                            else {\r\n                                end = mid - 1;\r\n                            }\r\n                        }\r\n                        if (insertionIndex === -1) {\r\n                            insertionIndex = start;\r\n                        }\r\n                        events.splice(insertionIndex, 0, event);\r\n                    }\r\n                    const isSync = event.timestamp < baselineTime;\r\n                    const castFn = getCastFn(event, isSync);\r\n                    if (isSync) {\r\n                        castFn();\r\n                    }\r\n                    else if (timer.isActive()) {\r\n                        timer.addAction({\r\n                            doAction: () => {\r\n                                castFn();\r\n                            },\r\n                            delay: event.delay,\r\n                        });\r\n                    }\r\n                }\r\n                return Object.assign(Object.assign({}, ctx), { events });\r\n            }),\r\n        },\r\n    });\r\n    return v(playerMachine);\r\n}\r\nfunction createSpeedService(context) {\r\n    const speedMachine = s({\r\n        id: 'speed',\r\n        context,\r\n        initial: 'normal',\r\n        states: {\r\n            normal: {\r\n                on: {\r\n                    FAST_FORWARD: {\r\n                        target: 'skipping',\r\n                        actions: ['recordSpeed', 'setSpeed'],\r\n                    },\r\n                    SET_SPEED: {\r\n                        target: 'normal',\r\n                        actions: ['setSpeed'],\r\n                    },\r\n                },\r\n            },\r\n            skipping: {\r\n                on: {\r\n                    BACK_TO_NORMAL: {\r\n                        target: 'normal',\r\n                        actions: ['restoreSpeed'],\r\n                    },\r\n                    SET_SPEED: {\r\n                        target: 'normal',\r\n                        actions: ['setSpeed'],\r\n                    },\r\n                },\r\n            },\r\n        },\r\n    }, {\r\n        actions: {\r\n            setSpeed: (ctx, event) => {\r\n                if ('payload' in event) {\r\n                    ctx.timer.setSpeed(event.payload.speed);\r\n                }\r\n            },\r\n            recordSpeed: o({\r\n                normalSpeed: (ctx) => ctx.timer.speed,\r\n            }),\r\n            restoreSpeed: (ctx) => {\r\n                ctx.timer.setSpeed(ctx.normalSpeed);\r\n            },\r\n        },\r\n    });\r\n    return v(speedMachine);\r\n}\n\nexport { createPlayerService, createSpeedService, discardPriorSnapshots };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}