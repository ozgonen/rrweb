{"ast":null,"code":"import { isShadowRoot, isNativeShadowDom, maskInputValue, transformAttribute, needMaskingText, IGNORED_NODE, serializeNodeWithId } from '../../../rrweb-snapshot/es/rrweb-snapshot.js';\nimport { isIgnored, isBlocked, isSerialized, isAncestorRemoved, isSerializedIframe, isSerializedStylesheet, hasShadowRoot } from '../utils.js';\nfunction isNodeInLinkedList(n) {\n  return '__ln' in n;\n}\nclass DoubleLinkedList {\n  constructor() {\n    this.length = 0;\n    this.head = null;\n  }\n  get(position) {\n    if (position >= this.length) {\n      throw new Error('Position outside of list range');\n    }\n    let current = this.head;\n    for (let index = 0; index < position; index++) {\n      current = (current === null || current === void 0 ? void 0 : current.next) || null;\n    }\n    return current;\n  }\n  addNode(n) {\n    const node = {\n      value: n,\n      previous: null,\n      next: null\n    };\n    n.__ln = node;\n    if (n.previousSibling && isNodeInLinkedList(n.previousSibling)) {\n      const current = n.previousSibling.__ln.next;\n      node.next = current;\n      node.previous = n.previousSibling.__ln;\n      n.previousSibling.__ln.next = node;\n      if (current) {\n        current.previous = node;\n      }\n    } else if (n.nextSibling && isNodeInLinkedList(n.nextSibling) && n.nextSibling.__ln.previous) {\n      const current = n.nextSibling.__ln.previous;\n      node.previous = current;\n      node.next = n.nextSibling.__ln;\n      n.nextSibling.__ln.previous = node;\n      if (current) {\n        current.next = node;\n      }\n    } else {\n      if (this.head) {\n        this.head.previous = node;\n      }\n      node.next = this.head;\n      this.head = node;\n    }\n    this.length++;\n  }\n  removeNode(n) {\n    const current = n.__ln;\n    if (!this.head) {\n      return;\n    }\n    if (!current.previous) {\n      this.head = current.next;\n      if (this.head) {\n        this.head.previous = null;\n      }\n    } else {\n      current.previous.next = current.next;\n      if (current.next) {\n        current.next.previous = current.previous;\n      }\n    }\n    if (n.__ln) {\n      delete n.__ln;\n    }\n    this.length--;\n  }\n}\nconst moveKey = (id, parentId) => `${id}@${parentId}`;\nclass MutationBuffer {\n  constructor() {\n    this.frozen = false;\n    this.locked = false;\n    this.texts = [];\n    this.attributes = [];\n    this.removes = [];\n    this.mapRemoves = [];\n    this.movedMap = {};\n    this.addedSet = new Set();\n    this.movedSet = new Set();\n    this.droppedSet = new Set();\n    this.processMutations = mutations => {\n      mutations.forEach(this.processMutation);\n      this.emit();\n    };\n    this.emit = () => {\n      if (this.frozen || this.locked) {\n        return;\n      }\n      const adds = [];\n      const addList = new DoubleLinkedList();\n      const getNextId = n => {\n        let ns = n;\n        let nextId = IGNORED_NODE;\n        while (nextId === IGNORED_NODE) {\n          ns = ns && ns.nextSibling;\n          nextId = ns && this.mirror.getId(ns);\n        }\n        return nextId;\n      };\n      const pushAdd = n => {\n        var _a, _b, _c, _d;\n        let shadowHost = null;\n        if (((_b = (_a = n.getRootNode) === null || _a === void 0 ? void 0 : _a.call(n)) === null || _b === void 0 ? void 0 : _b.nodeType) === Node.DOCUMENT_FRAGMENT_NODE && n.getRootNode().host) shadowHost = n.getRootNode().host;\n        let rootShadowHost = shadowHost;\n        while (((_d = (_c = rootShadowHost === null || rootShadowHost === void 0 ? void 0 : rootShadowHost.getRootNode) === null || _c === void 0 ? void 0 : _c.call(rootShadowHost)) === null || _d === void 0 ? void 0 : _d.nodeType) === Node.DOCUMENT_FRAGMENT_NODE && rootShadowHost.getRootNode().host) rootShadowHost = rootShadowHost.getRootNode().host;\n        const notInDoc = !this.doc.contains(n) && (!rootShadowHost || !this.doc.contains(rootShadowHost));\n        if (!n.parentNode || notInDoc) {\n          return;\n        }\n        const parentId = isShadowRoot(n.parentNode) ? this.mirror.getId(shadowHost) : this.mirror.getId(n.parentNode);\n        const nextId = getNextId(n);\n        if (parentId === -1 || nextId === -1) {\n          return addList.addNode(n);\n        }\n        const sn = serializeNodeWithId(n, {\n          doc: this.doc,\n          mirror: this.mirror,\n          blockClass: this.blockClass,\n          blockSelector: this.blockSelector,\n          maskTextClass: this.maskTextClass,\n          maskTextSelector: this.maskTextSelector,\n          skipChild: true,\n          newlyAddedElement: true,\n          inlineStylesheet: this.inlineStylesheet,\n          maskInputOptions: this.maskInputOptions,\n          maskTextFn: this.maskTextFn,\n          maskInputFn: this.maskInputFn,\n          slimDOMOptions: this.slimDOMOptions,\n          dataURLOptions: this.dataURLOptions,\n          recordCanvas: this.recordCanvas,\n          inlineImages: this.inlineImages,\n          onSerialize: currentN => {\n            if (isSerializedIframe(currentN, this.mirror)) {\n              this.iframeManager.addIframe(currentN);\n            }\n            if (isSerializedStylesheet(currentN, this.mirror)) {\n              this.stylesheetManager.trackLinkElement(currentN);\n            }\n            if (hasShadowRoot(n)) {\n              this.shadowDomManager.addShadowRoot(n.shadowRoot, this.doc);\n            }\n          },\n          onIframeLoad: (iframe, childSn) => {\n            this.iframeManager.attachIframe(iframe, childSn);\n            this.shadowDomManager.observeAttachShadow(iframe);\n          },\n          onStylesheetLoad: (link, childSn) => {\n            this.stylesheetManager.attachLinkElement(link, childSn);\n          }\n        });\n        if (sn) {\n          adds.push({\n            parentId,\n            nextId,\n            node: sn\n          });\n        }\n      };\n      while (this.mapRemoves.length) {\n        this.mirror.removeNodeFromMap(this.mapRemoves.shift());\n      }\n      for (const n of Array.from(this.movedSet.values())) {\n        if (isParentRemoved(this.removes, n, this.mirror) && !this.movedSet.has(n.parentNode)) {\n          continue;\n        }\n        pushAdd(n);\n      }\n      for (const n of Array.from(this.addedSet.values())) {\n        if (!isAncestorInSet(this.droppedSet, n) && !isParentRemoved(this.removes, n, this.mirror)) {\n          pushAdd(n);\n        } else if (isAncestorInSet(this.movedSet, n)) {\n          pushAdd(n);\n        } else {\n          this.droppedSet.add(n);\n        }\n      }\n      let candidate = null;\n      while (addList.length) {\n        let node = null;\n        if (candidate) {\n          const parentId = this.mirror.getId(candidate.value.parentNode);\n          const nextId = getNextId(candidate.value);\n          if (parentId !== -1 && nextId !== -1) {\n            node = candidate;\n          }\n        }\n        if (!node) {\n          for (let index = addList.length - 1; index >= 0; index--) {\n            const _node = addList.get(index);\n            if (_node) {\n              const parentId = this.mirror.getId(_node.value.parentNode);\n              const nextId = getNextId(_node.value);\n              if (nextId === -1) continue;else if (parentId !== -1) {\n                node = _node;\n                break;\n              } else {\n                const unhandledNode = _node.value;\n                if (unhandledNode.parentNode && unhandledNode.parentNode.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {\n                  const shadowHost = unhandledNode.parentNode.host;\n                  const parentId = this.mirror.getId(shadowHost);\n                  if (parentId !== -1) {\n                    node = _node;\n                    break;\n                  }\n                }\n              }\n            }\n          }\n        }\n        if (!node) {\n          while (addList.head) {\n            addList.removeNode(addList.head.value);\n          }\n          break;\n        }\n        candidate = node.previous;\n        addList.removeNode(node.value);\n        pushAdd(node.value);\n      }\n      const payload = {\n        texts: this.texts.map(text => ({\n          id: this.mirror.getId(text.node),\n          value: text.value\n        })).filter(text => this.mirror.has(text.id)),\n        attributes: this.attributes.map(attribute => ({\n          id: this.mirror.getId(attribute.node),\n          attributes: attribute.attributes\n        })).filter(attribute => this.mirror.has(attribute.id)),\n        removes: this.removes,\n        adds\n      };\n      if (!payload.texts.length && !payload.attributes.length && !payload.removes.length && !payload.adds.length) {\n        return;\n      }\n      this.texts = [];\n      this.attributes = [];\n      this.removes = [];\n      this.addedSet = new Set();\n      this.movedSet = new Set();\n      this.droppedSet = new Set();\n      this.movedMap = {};\n      this.mutationCb(payload);\n    };\n    this.processMutation = m => {\n      if (isIgnored(m.target, this.mirror)) {\n        return;\n      }\n      switch (m.type) {\n        case 'characterData':\n          {\n            const value = m.target.textContent;\n            if (!isBlocked(m.target, this.blockClass, this.blockSelector, false) && value !== m.oldValue) {\n              this.texts.push({\n                value: needMaskingText(m.target, this.maskTextClass, this.maskTextSelector) && value ? this.maskTextFn ? this.maskTextFn(value) : value.replace(/[\\S]/g, '*') : value,\n                node: m.target\n              });\n            }\n            break;\n          }\n        case 'attributes':\n          {\n            const target = m.target;\n            let value = m.target.getAttribute(m.attributeName);\n            if (m.attributeName === 'value') {\n              value = maskInputValue({\n                maskInputOptions: this.maskInputOptions,\n                tagName: m.target.tagName,\n                type: m.target.getAttribute('type'),\n                value,\n                maskInputFn: this.maskInputFn\n              });\n            }\n            if (isBlocked(m.target, this.blockClass, this.blockSelector, false) || value === m.oldValue) {\n              return;\n            }\n            let item = this.attributes.find(a => a.node === m.target);\n            if (target.tagName === 'IFRAME' && m.attributeName === 'src' && !this.keepIframeSrcFn(value)) {\n              if (!target.contentDocument) {\n                m.attributeName = 'rr_src';\n              } else {\n                return;\n              }\n            }\n            if (!item) {\n              item = {\n                node: m.target,\n                attributes: {}\n              };\n              this.attributes.push(item);\n            }\n            if (m.attributeName === 'style') {\n              const old = this.doc.createElement('span');\n              if (m.oldValue) {\n                old.setAttribute('style', m.oldValue);\n              }\n              if (item.attributes.style === undefined || item.attributes.style === null) {\n                item.attributes.style = {};\n              }\n              const styleObj = item.attributes.style;\n              for (const pname of Array.from(target.style)) {\n                const newValue = target.style.getPropertyValue(pname);\n                const newPriority = target.style.getPropertyPriority(pname);\n                if (newValue !== old.style.getPropertyValue(pname) || newPriority !== old.style.getPropertyPriority(pname)) {\n                  if (newPriority === '') {\n                    styleObj[pname] = newValue;\n                  } else {\n                    styleObj[pname] = [newValue, newPriority];\n                  }\n                }\n              }\n              for (const pname of Array.from(old.style)) {\n                if (target.style.getPropertyValue(pname) === '') {\n                  styleObj[pname] = false;\n                }\n              }\n            } else {\n              item.attributes[m.attributeName] = transformAttribute(this.doc, target.tagName, m.attributeName, value);\n            }\n            break;\n          }\n        case 'childList':\n          {\n            if (isBlocked(m.target, this.blockClass, this.blockSelector, true)) return;\n            m.addedNodes.forEach(n => this.genAdds(n, m.target));\n            m.removedNodes.forEach(n => {\n              const nodeId = this.mirror.getId(n);\n              const parentId = isShadowRoot(m.target) ? this.mirror.getId(m.target.host) : this.mirror.getId(m.target);\n              if (isBlocked(m.target, this.blockClass, this.blockSelector, false) || isIgnored(n, this.mirror) || !isSerialized(n, this.mirror)) {\n                return;\n              }\n              if (this.addedSet.has(n)) {\n                deepDelete(this.addedSet, n);\n                this.droppedSet.add(n);\n              } else if (this.addedSet.has(m.target) && nodeId === -1) ;else if (isAncestorRemoved(m.target, this.mirror)) ;else if (this.movedSet.has(n) && this.movedMap[moveKey(nodeId, parentId)]) {\n                deepDelete(this.movedSet, n);\n              } else {\n                this.removes.push({\n                  parentId,\n                  id: nodeId,\n                  isShadow: isShadowRoot(m.target) && isNativeShadowDom(m.target) ? true : undefined\n                });\n              }\n              this.mapRemoves.push(n);\n            });\n            break;\n          }\n      }\n    };\n    this.genAdds = (n, target) => {\n      if (this.mirror.hasNode(n)) {\n        if (isIgnored(n, this.mirror)) {\n          return;\n        }\n        this.movedSet.add(n);\n        let targetId = null;\n        if (target && this.mirror.hasNode(target)) {\n          targetId = this.mirror.getId(target);\n        }\n        if (targetId && targetId !== -1) {\n          this.movedMap[moveKey(this.mirror.getId(n), targetId)] = true;\n        }\n      } else {\n        this.addedSet.add(n);\n        this.droppedSet.delete(n);\n      }\n      if (!isBlocked(n, this.blockClass, this.blockSelector, false)) n.childNodes.forEach(childN => this.genAdds(childN));\n    };\n  }\n  init(options) {\n    ['mutationCb', 'blockClass', 'blockSelector', 'maskTextClass', 'maskTextSelector', 'inlineStylesheet', 'maskInputOptions', 'maskTextFn', 'maskInputFn', 'keepIframeSrcFn', 'recordCanvas', 'inlineImages', 'slimDOMOptions', 'dataURLOptions', 'doc', 'mirror', 'iframeManager', 'stylesheetManager', 'shadowDomManager', 'canvasManager'].forEach(key => {\n      this[key] = options[key];\n    });\n  }\n  freeze() {\n    this.frozen = true;\n    this.canvasManager.freeze();\n  }\n  unfreeze() {\n    this.frozen = false;\n    this.canvasManager.unfreeze();\n    this.emit();\n  }\n  isFrozen() {\n    return this.frozen;\n  }\n  lock() {\n    this.locked = true;\n    this.canvasManager.lock();\n  }\n  unlock() {\n    this.locked = false;\n    this.canvasManager.unlock();\n    this.emit();\n  }\n  reset() {\n    this.shadowDomManager.reset();\n    this.canvasManager.reset();\n  }\n}\nfunction deepDelete(addsSet, n) {\n  addsSet.delete(n);\n  n.childNodes.forEach(childN => deepDelete(addsSet, childN));\n}\nfunction isParentRemoved(removes, n, mirror) {\n  if (removes.length === 0) return false;\n  return _isParentRemoved(removes, n, mirror);\n}\nfunction _isParentRemoved(removes, n, mirror) {\n  const {\n    parentNode\n  } = n;\n  if (!parentNode) {\n    return false;\n  }\n  const parentId = mirror.getId(parentNode);\n  if (removes.some(r => r.id === parentId)) {\n    return true;\n  }\n  return _isParentRemoved(removes, parentNode, mirror);\n}\nfunction isAncestorInSet(set, n) {\n  if (set.size === 0) return false;\n  return _isAncestorInSet(set, n);\n}\nfunction _isAncestorInSet(set, n) {\n  const {\n    parentNode\n  } = n;\n  if (!parentNode) {\n    return false;\n  }\n  if (set.has(parentNode)) {\n    return true;\n  }\n  return _isAncestorInSet(set, parentNode);\n}\nexport { MutationBuffer as default };","map":{"version":3,"names":["isShadowRoot","isNativeShadowDom","maskInputValue","transformAttribute","needMaskingText","IGNORED_NODE","serializeNodeWithId","isIgnored","isBlocked","isSerialized","isAncestorRemoved","isSerializedIframe","isSerializedStylesheet","hasShadowRoot","isNodeInLinkedList","n","DoubleLinkedList","constructor","length","head","get","position","Error","current","index","next","addNode","node","value","previous","__ln","previousSibling","nextSibling","removeNode","moveKey","id","parentId","MutationBuffer","frozen","locked","texts","attributes","removes","mapRemoves","movedMap","addedSet","Set","movedSet","droppedSet","processMutations","mutations","forEach","processMutation","emit","adds","addList","getNextId","ns","nextId","mirror","getId","pushAdd","_a","_b","_c","_d","shadowHost","getRootNode","call","nodeType","Node","DOCUMENT_FRAGMENT_NODE","host","rootShadowHost","notInDoc","doc","contains","parentNode","sn","blockClass","blockSelector","maskTextClass","maskTextSelector","skipChild","newlyAddedElement","inlineStylesheet","maskInputOptions","maskTextFn","maskInputFn","slimDOMOptions","dataURLOptions","recordCanvas","inlineImages","onSerialize","currentN","iframeManager","addIframe","stylesheetManager","trackLinkElement","shadowDomManager","addShadowRoot","shadowRoot","onIframeLoad","iframe","childSn","attachIframe","observeAttachShadow","onStylesheetLoad","link","attachLinkElement","push","removeNodeFromMap","shift","Array","from","values","isParentRemoved","has","isAncestorInSet","add","candidate","_node","unhandledNode","payload","map","text","filter","attribute","mutationCb","m","target","type","textContent","oldValue","replace","getAttribute","attributeName","tagName","item","find","a","keepIframeSrcFn","contentDocument","old","createElement","setAttribute","style","undefined","styleObj","pname","newValue","getPropertyValue","newPriority","getPropertyPriority","addedNodes","genAdds","removedNodes","nodeId","deepDelete","isShadow","hasNode","targetId","delete","childNodes","childN","init","options","key","freeze","canvasManager","unfreeze","isFrozen","lock","unlock","reset","addsSet","_isParentRemoved","some","r","set","size","_isAncestorInSet","default"],"sources":["/Users/ogonen/rrweb/node_modules/rrweb/es/rrweb/packages/rrweb/src/record/mutation.js"],"sourcesContent":["import { isShadowRoot, isNativeShadowDom, maskInputValue, transformAttribute, needMaskingText, IGNORED_NODE, serializeNodeWithId } from '../../../rrweb-snapshot/es/rrweb-snapshot.js';\nimport { isIgnored, isBlocked, isSerialized, isAncestorRemoved, isSerializedIframe, isSerializedStylesheet, hasShadowRoot } from '../utils.js';\n\nfunction isNodeInLinkedList(n) {\r\n    return '__ln' in n;\r\n}\r\nclass DoubleLinkedList {\r\n    constructor() {\r\n        this.length = 0;\r\n        this.head = null;\r\n    }\r\n    get(position) {\r\n        if (position >= this.length) {\r\n            throw new Error('Position outside of list range');\r\n        }\r\n        let current = this.head;\r\n        for (let index = 0; index < position; index++) {\r\n            current = (current === null || current === void 0 ? void 0 : current.next) || null;\r\n        }\r\n        return current;\r\n    }\r\n    addNode(n) {\r\n        const node = {\r\n            value: n,\r\n            previous: null,\r\n            next: null,\r\n        };\r\n        n.__ln = node;\r\n        if (n.previousSibling && isNodeInLinkedList(n.previousSibling)) {\r\n            const current = n.previousSibling.__ln.next;\r\n            node.next = current;\r\n            node.previous = n.previousSibling.__ln;\r\n            n.previousSibling.__ln.next = node;\r\n            if (current) {\r\n                current.previous = node;\r\n            }\r\n        }\r\n        else if (n.nextSibling &&\r\n            isNodeInLinkedList(n.nextSibling) &&\r\n            n.nextSibling.__ln.previous) {\r\n            const current = n.nextSibling.__ln.previous;\r\n            node.previous = current;\r\n            node.next = n.nextSibling.__ln;\r\n            n.nextSibling.__ln.previous = node;\r\n            if (current) {\r\n                current.next = node;\r\n            }\r\n        }\r\n        else {\r\n            if (this.head) {\r\n                this.head.previous = node;\r\n            }\r\n            node.next = this.head;\r\n            this.head = node;\r\n        }\r\n        this.length++;\r\n    }\r\n    removeNode(n) {\r\n        const current = n.__ln;\r\n        if (!this.head) {\r\n            return;\r\n        }\r\n        if (!current.previous) {\r\n            this.head = current.next;\r\n            if (this.head) {\r\n                this.head.previous = null;\r\n            }\r\n        }\r\n        else {\r\n            current.previous.next = current.next;\r\n            if (current.next) {\r\n                current.next.previous = current.previous;\r\n            }\r\n        }\r\n        if (n.__ln) {\r\n            delete n.__ln;\r\n        }\r\n        this.length--;\r\n    }\r\n}\r\nconst moveKey = (id, parentId) => `${id}@${parentId}`;\r\nclass MutationBuffer {\r\n    constructor() {\r\n        this.frozen = false;\r\n        this.locked = false;\r\n        this.texts = [];\r\n        this.attributes = [];\r\n        this.removes = [];\r\n        this.mapRemoves = [];\r\n        this.movedMap = {};\r\n        this.addedSet = new Set();\r\n        this.movedSet = new Set();\r\n        this.droppedSet = new Set();\r\n        this.processMutations = (mutations) => {\r\n            mutations.forEach(this.processMutation);\r\n            this.emit();\r\n        };\r\n        this.emit = () => {\r\n            if (this.frozen || this.locked) {\r\n                return;\r\n            }\r\n            const adds = [];\r\n            const addList = new DoubleLinkedList();\r\n            const getNextId = (n) => {\r\n                let ns = n;\r\n                let nextId = IGNORED_NODE;\r\n                while (nextId === IGNORED_NODE) {\r\n                    ns = ns && ns.nextSibling;\r\n                    nextId = ns && this.mirror.getId(ns);\r\n                }\r\n                return nextId;\r\n            };\r\n            const pushAdd = (n) => {\r\n                var _a, _b, _c, _d;\r\n                let shadowHost = null;\r\n                if (((_b = (_a = n.getRootNode) === null || _a === void 0 ? void 0 : _a.call(n)) === null || _b === void 0 ? void 0 : _b.nodeType) === Node.DOCUMENT_FRAGMENT_NODE &&\r\n                    n.getRootNode().host)\r\n                    shadowHost = n.getRootNode().host;\r\n                let rootShadowHost = shadowHost;\r\n                while (((_d = (_c = rootShadowHost === null || rootShadowHost === void 0 ? void 0 : rootShadowHost.getRootNode) === null || _c === void 0 ? void 0 : _c.call(rootShadowHost)) === null || _d === void 0 ? void 0 : _d.nodeType) ===\r\n                    Node.DOCUMENT_FRAGMENT_NODE &&\r\n                    rootShadowHost.getRootNode().host)\r\n                    rootShadowHost = rootShadowHost.getRootNode().host;\r\n                const notInDoc = !this.doc.contains(n) &&\r\n                    (!rootShadowHost || !this.doc.contains(rootShadowHost));\r\n                if (!n.parentNode || notInDoc) {\r\n                    return;\r\n                }\r\n                const parentId = isShadowRoot(n.parentNode)\r\n                    ? this.mirror.getId(shadowHost)\r\n                    : this.mirror.getId(n.parentNode);\r\n                const nextId = getNextId(n);\r\n                if (parentId === -1 || nextId === -1) {\r\n                    return addList.addNode(n);\r\n                }\r\n                const sn = serializeNodeWithId(n, {\r\n                    doc: this.doc,\r\n                    mirror: this.mirror,\r\n                    blockClass: this.blockClass,\r\n                    blockSelector: this.blockSelector,\r\n                    maskTextClass: this.maskTextClass,\r\n                    maskTextSelector: this.maskTextSelector,\r\n                    skipChild: true,\r\n                    newlyAddedElement: true,\r\n                    inlineStylesheet: this.inlineStylesheet,\r\n                    maskInputOptions: this.maskInputOptions,\r\n                    maskTextFn: this.maskTextFn,\r\n                    maskInputFn: this.maskInputFn,\r\n                    slimDOMOptions: this.slimDOMOptions,\r\n                    dataURLOptions: this.dataURLOptions,\r\n                    recordCanvas: this.recordCanvas,\r\n                    inlineImages: this.inlineImages,\r\n                    onSerialize: (currentN) => {\r\n                        if (isSerializedIframe(currentN, this.mirror)) {\r\n                            this.iframeManager.addIframe(currentN);\r\n                        }\r\n                        if (isSerializedStylesheet(currentN, this.mirror)) {\r\n                            this.stylesheetManager.trackLinkElement(currentN);\r\n                        }\r\n                        if (hasShadowRoot(n)) {\r\n                            this.shadowDomManager.addShadowRoot(n.shadowRoot, this.doc);\r\n                        }\r\n                    },\r\n                    onIframeLoad: (iframe, childSn) => {\r\n                        this.iframeManager.attachIframe(iframe, childSn);\r\n                        this.shadowDomManager.observeAttachShadow(iframe);\r\n                    },\r\n                    onStylesheetLoad: (link, childSn) => {\r\n                        this.stylesheetManager.attachLinkElement(link, childSn);\r\n                    },\r\n                });\r\n                if (sn) {\r\n                    adds.push({\r\n                        parentId,\r\n                        nextId,\r\n                        node: sn,\r\n                    });\r\n                }\r\n            };\r\n            while (this.mapRemoves.length) {\r\n                this.mirror.removeNodeFromMap(this.mapRemoves.shift());\r\n            }\r\n            for (const n of Array.from(this.movedSet.values())) {\r\n                if (isParentRemoved(this.removes, n, this.mirror) &&\r\n                    !this.movedSet.has(n.parentNode)) {\r\n                    continue;\r\n                }\r\n                pushAdd(n);\r\n            }\r\n            for (const n of Array.from(this.addedSet.values())) {\r\n                if (!isAncestorInSet(this.droppedSet, n) &&\r\n                    !isParentRemoved(this.removes, n, this.mirror)) {\r\n                    pushAdd(n);\r\n                }\r\n                else if (isAncestorInSet(this.movedSet, n)) {\r\n                    pushAdd(n);\r\n                }\r\n                else {\r\n                    this.droppedSet.add(n);\r\n                }\r\n            }\r\n            let candidate = null;\r\n            while (addList.length) {\r\n                let node = null;\r\n                if (candidate) {\r\n                    const parentId = this.mirror.getId(candidate.value.parentNode);\r\n                    const nextId = getNextId(candidate.value);\r\n                    if (parentId !== -1 && nextId !== -1) {\r\n                        node = candidate;\r\n                    }\r\n                }\r\n                if (!node) {\r\n                    for (let index = addList.length - 1; index >= 0; index--) {\r\n                        const _node = addList.get(index);\r\n                        if (_node) {\r\n                            const parentId = this.mirror.getId(_node.value.parentNode);\r\n                            const nextId = getNextId(_node.value);\r\n                            if (nextId === -1)\r\n                                continue;\r\n                            else if (parentId !== -1) {\r\n                                node = _node;\r\n                                break;\r\n                            }\r\n                            else {\r\n                                const unhandledNode = _node.value;\r\n                                if (unhandledNode.parentNode &&\r\n                                    unhandledNode.parentNode.nodeType ===\r\n                                        Node.DOCUMENT_FRAGMENT_NODE) {\r\n                                    const shadowHost = unhandledNode.parentNode\r\n                                        .host;\r\n                                    const parentId = this.mirror.getId(shadowHost);\r\n                                    if (parentId !== -1) {\r\n                                        node = _node;\r\n                                        break;\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                if (!node) {\r\n                    while (addList.head) {\r\n                        addList.removeNode(addList.head.value);\r\n                    }\r\n                    break;\r\n                }\r\n                candidate = node.previous;\r\n                addList.removeNode(node.value);\r\n                pushAdd(node.value);\r\n            }\r\n            const payload = {\r\n                texts: this.texts\r\n                    .map((text) => ({\r\n                    id: this.mirror.getId(text.node),\r\n                    value: text.value,\r\n                }))\r\n                    .filter((text) => this.mirror.has(text.id)),\r\n                attributes: this.attributes\r\n                    .map((attribute) => ({\r\n                    id: this.mirror.getId(attribute.node),\r\n                    attributes: attribute.attributes,\r\n                }))\r\n                    .filter((attribute) => this.mirror.has(attribute.id)),\r\n                removes: this.removes,\r\n                adds,\r\n            };\r\n            if (!payload.texts.length &&\r\n                !payload.attributes.length &&\r\n                !payload.removes.length &&\r\n                !payload.adds.length) {\r\n                return;\r\n            }\r\n            this.texts = [];\r\n            this.attributes = [];\r\n            this.removes = [];\r\n            this.addedSet = new Set();\r\n            this.movedSet = new Set();\r\n            this.droppedSet = new Set();\r\n            this.movedMap = {};\r\n            this.mutationCb(payload);\r\n        };\r\n        this.processMutation = (m) => {\r\n            if (isIgnored(m.target, this.mirror)) {\r\n                return;\r\n            }\r\n            switch (m.type) {\r\n                case 'characterData': {\r\n                    const value = m.target.textContent;\r\n                    if (!isBlocked(m.target, this.blockClass, this.blockSelector, false) &&\r\n                        value !== m.oldValue) {\r\n                        this.texts.push({\r\n                            value: needMaskingText(m.target, this.maskTextClass, this.maskTextSelector) && value\r\n                                ? this.maskTextFn\r\n                                    ? this.maskTextFn(value)\r\n                                    : value.replace(/[\\S]/g, '*')\r\n                                : value,\r\n                            node: m.target,\r\n                        });\r\n                    }\r\n                    break;\r\n                }\r\n                case 'attributes': {\r\n                    const target = m.target;\r\n                    let value = m.target.getAttribute(m.attributeName);\r\n                    if (m.attributeName === 'value') {\r\n                        value = maskInputValue({\r\n                            maskInputOptions: this.maskInputOptions,\r\n                            tagName: m.target.tagName,\r\n                            type: m.target.getAttribute('type'),\r\n                            value,\r\n                            maskInputFn: this.maskInputFn,\r\n                        });\r\n                    }\r\n                    if (isBlocked(m.target, this.blockClass, this.blockSelector, false) ||\r\n                        value === m.oldValue) {\r\n                        return;\r\n                    }\r\n                    let item = this.attributes.find((a) => a.node === m.target);\r\n                    if (target.tagName === 'IFRAME' &&\r\n                        m.attributeName === 'src' &&\r\n                        !this.keepIframeSrcFn(value)) {\r\n                        if (!target.contentDocument) {\r\n                            m.attributeName = 'rr_src';\r\n                        }\r\n                        else {\r\n                            return;\r\n                        }\r\n                    }\r\n                    if (!item) {\r\n                        item = {\r\n                            node: m.target,\r\n                            attributes: {},\r\n                        };\r\n                        this.attributes.push(item);\r\n                    }\r\n                    if (m.attributeName === 'style') {\r\n                        const old = this.doc.createElement('span');\r\n                        if (m.oldValue) {\r\n                            old.setAttribute('style', m.oldValue);\r\n                        }\r\n                        if (item.attributes.style === undefined ||\r\n                            item.attributes.style === null) {\r\n                            item.attributes.style = {};\r\n                        }\r\n                        const styleObj = item.attributes.style;\r\n                        for (const pname of Array.from(target.style)) {\r\n                            const newValue = target.style.getPropertyValue(pname);\r\n                            const newPriority = target.style.getPropertyPriority(pname);\r\n                            if (newValue !== old.style.getPropertyValue(pname) ||\r\n                                newPriority !== old.style.getPropertyPriority(pname)) {\r\n                                if (newPriority === '') {\r\n                                    styleObj[pname] = newValue;\r\n                                }\r\n                                else {\r\n                                    styleObj[pname] = [newValue, newPriority];\r\n                                }\r\n                            }\r\n                        }\r\n                        for (const pname of Array.from(old.style)) {\r\n                            if (target.style.getPropertyValue(pname) === '') {\r\n                                styleObj[pname] = false;\r\n                            }\r\n                        }\r\n                    }\r\n                    else {\r\n                        item.attributes[m.attributeName] = transformAttribute(this.doc, target.tagName, m.attributeName, value);\r\n                    }\r\n                    break;\r\n                }\r\n                case 'childList': {\r\n                    if (isBlocked(m.target, this.blockClass, this.blockSelector, true))\r\n                        return;\r\n                    m.addedNodes.forEach((n) => this.genAdds(n, m.target));\r\n                    m.removedNodes.forEach((n) => {\r\n                        const nodeId = this.mirror.getId(n);\r\n                        const parentId = isShadowRoot(m.target)\r\n                            ? this.mirror.getId(m.target.host)\r\n                            : this.mirror.getId(m.target);\r\n                        if (isBlocked(m.target, this.blockClass, this.blockSelector, false) ||\r\n                            isIgnored(n, this.mirror) ||\r\n                            !isSerialized(n, this.mirror)) {\r\n                            return;\r\n                        }\r\n                        if (this.addedSet.has(n)) {\r\n                            deepDelete(this.addedSet, n);\r\n                            this.droppedSet.add(n);\r\n                        }\r\n                        else if (this.addedSet.has(m.target) && nodeId === -1) ;\r\n                        else if (isAncestorRemoved(m.target, this.mirror)) ;\r\n                        else if (this.movedSet.has(n) &&\r\n                            this.movedMap[moveKey(nodeId, parentId)]) {\r\n                            deepDelete(this.movedSet, n);\r\n                        }\r\n                        else {\r\n                            this.removes.push({\r\n                                parentId,\r\n                                id: nodeId,\r\n                                isShadow: isShadowRoot(m.target) && isNativeShadowDom(m.target)\r\n                                    ? true\r\n                                    : undefined,\r\n                            });\r\n                        }\r\n                        this.mapRemoves.push(n);\r\n                    });\r\n                    break;\r\n                }\r\n            }\r\n        };\r\n        this.genAdds = (n, target) => {\r\n            if (this.mirror.hasNode(n)) {\r\n                if (isIgnored(n, this.mirror)) {\r\n                    return;\r\n                }\r\n                this.movedSet.add(n);\r\n                let targetId = null;\r\n                if (target && this.mirror.hasNode(target)) {\r\n                    targetId = this.mirror.getId(target);\r\n                }\r\n                if (targetId && targetId !== -1) {\r\n                    this.movedMap[moveKey(this.mirror.getId(n), targetId)] = true;\r\n                }\r\n            }\r\n            else {\r\n                this.addedSet.add(n);\r\n                this.droppedSet.delete(n);\r\n            }\r\n            if (!isBlocked(n, this.blockClass, this.blockSelector, false))\r\n                n.childNodes.forEach((childN) => this.genAdds(childN));\r\n        };\r\n    }\r\n    init(options) {\r\n        [\r\n            'mutationCb',\r\n            'blockClass',\r\n            'blockSelector',\r\n            'maskTextClass',\r\n            'maskTextSelector',\r\n            'inlineStylesheet',\r\n            'maskInputOptions',\r\n            'maskTextFn',\r\n            'maskInputFn',\r\n            'keepIframeSrcFn',\r\n            'recordCanvas',\r\n            'inlineImages',\r\n            'slimDOMOptions',\r\n            'dataURLOptions',\r\n            'doc',\r\n            'mirror',\r\n            'iframeManager',\r\n            'stylesheetManager',\r\n            'shadowDomManager',\r\n            'canvasManager',\r\n        ].forEach((key) => {\r\n            this[key] = options[key];\r\n        });\r\n    }\r\n    freeze() {\r\n        this.frozen = true;\r\n        this.canvasManager.freeze();\r\n    }\r\n    unfreeze() {\r\n        this.frozen = false;\r\n        this.canvasManager.unfreeze();\r\n        this.emit();\r\n    }\r\n    isFrozen() {\r\n        return this.frozen;\r\n    }\r\n    lock() {\r\n        this.locked = true;\r\n        this.canvasManager.lock();\r\n    }\r\n    unlock() {\r\n        this.locked = false;\r\n        this.canvasManager.unlock();\r\n        this.emit();\r\n    }\r\n    reset() {\r\n        this.shadowDomManager.reset();\r\n        this.canvasManager.reset();\r\n    }\r\n}\r\nfunction deepDelete(addsSet, n) {\r\n    addsSet.delete(n);\r\n    n.childNodes.forEach((childN) => deepDelete(addsSet, childN));\r\n}\r\nfunction isParentRemoved(removes, n, mirror) {\r\n    if (removes.length === 0)\r\n        return false;\r\n    return _isParentRemoved(removes, n, mirror);\r\n}\r\nfunction _isParentRemoved(removes, n, mirror) {\r\n    const { parentNode } = n;\r\n    if (!parentNode) {\r\n        return false;\r\n    }\r\n    const parentId = mirror.getId(parentNode);\r\n    if (removes.some((r) => r.id === parentId)) {\r\n        return true;\r\n    }\r\n    return _isParentRemoved(removes, parentNode, mirror);\r\n}\r\nfunction isAncestorInSet(set, n) {\r\n    if (set.size === 0)\r\n        return false;\r\n    return _isAncestorInSet(set, n);\r\n}\r\nfunction _isAncestorInSet(set, n) {\r\n    const { parentNode } = n;\r\n    if (!parentNode) {\r\n        return false;\r\n    }\r\n    if (set.has(parentNode)) {\r\n        return true;\r\n    }\r\n    return _isAncestorInSet(set, parentNode);\r\n}\n\nexport { MutationBuffer as default };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}