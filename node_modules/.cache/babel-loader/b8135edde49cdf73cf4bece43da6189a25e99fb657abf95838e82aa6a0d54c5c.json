{"ast":null,"code":"// RecordingCutter.js - Utility for cutting rrweb recordings into smaller clips\n\n/**\n * Converts relative seconds to absolute timestamp\n * @param {Array} events - rrweb events array\n * @param {number} relativeSeconds - Seconds from start of recording\n * @returns {number} Absolute timestamp\n */\nexport function relativeTimeToTimestamp(events, relativeSeconds) {\n  if (!events || events.length === 0) return 0;\n  const startTime = events[0].timestamp;\n  return startTime + relativeSeconds * 1000;\n}\n\n/**\n * Converts absolute timestamp to relative seconds\n * @param {Array} events - rrweb events array\n * @param {number} timestamp - Absolute timestamp\n * @returns {number} Relative seconds from start\n */\nexport function timestampToRelativeTime(events, timestamp) {\n  if (!events || events.length === 0) return 0;\n  const startTime = events[0].timestamp;\n  return (timestamp - startTime) / 1000;\n}\n\n/**\n * Formats seconds as MM:SS or HH:MM:SS\n * @param {number} seconds - Total seconds\n * @returns {string} Formatted time string\n */\nexport function formatTime(seconds) {\n  const hours = Math.floor(seconds / 3600);\n  const minutes = Math.floor(seconds % 3600 / 60);\n  const secs = Math.floor(seconds % 60);\n  if (hours > 0) {\n    return `${hours}:${minutes.toString().padStart(2, \"0\")}:${secs.toString().padStart(2, \"0\")}`;\n  }\n  return `${minutes}:${secs.toString().padStart(2, \"0\")}`;\n}\n\n/**\n * Parses time string (MM:SS, HH:MM:SS, or just seconds) to total seconds\n * @param {string} timeStr - Time string like \"1:30\", \"0:05\", \"90\", etc.\n * @returns {number} Total seconds\n */\nexport function parseTimeString(timeStr) {\n  if (!timeStr) return 0;\n\n  // If it's just a number, treat as seconds\n  if (/^\\d+$/.test(timeStr)) {\n    return parseInt(timeStr);\n  }\n\n  // Parse MM:SS or HH:MM:SS format\n  const parts = timeStr.split(\":\").map(Number);\n  if (parts.length === 2) {\n    // MM:SS\n    return parts[0] * 60 + parts[1];\n  } else if (parts.length === 3) {\n    // HH:MM:SS\n    return parts[0] * 3600 + parts[1] * 60 + parts[2];\n  }\n  return 0;\n}\n\n/**\n * Creates a synthetic full snapshot by replaying the recording up to a specific point\n * @param {Array} events - Original rrweb events array\n * @param {number} targetTimestamp - The timestamp to build the DOM state up to\n * @returns {Object} Synthetic full snapshot representing the DOM state at targetTimestamp\n */\nfunction createSyntheticSnapshot(events, targetTimestamp) {\n  console.log(`Creating synthetic full snapshot at ${targetTimestamp}ms`);\n\n  // Find the last full snapshot before our target time\n  let baseSnapshot = null;\n  for (const event of events) {\n    if (event.type === 2 && event.timestamp <= targetTimestamp) {\n      if (!baseSnapshot || event.timestamp > baseSnapshot.timestamp) {\n        baseSnapshot = event;\n      }\n    }\n  }\n  if (!baseSnapshot) {\n    // No full snapshot before target - use the first one\n    baseSnapshot = events.find(e => e.type === 2);\n    if (!baseSnapshot) {\n      throw new Error(\"No full snapshot found in recording\");\n    }\n  }\n  console.log(`Found base snapshot at ${baseSnapshot.timestamp}ms`);\n\n  // Deep clone the base snapshot\n  const syntheticSnapshot = JSON.parse(JSON.stringify(baseSnapshot));\n  syntheticSnapshot.timestamp = targetTimestamp;\n\n  // To properly apply incremental changes, we would need rrweb's internal\n  // DOM reconstruction logic. For now, we'll return the base snapshot at the new time.\n  // This approach preserves the DOM structure while adjusting timing.\n\n  // In a full implementation, we would:\n  // 1. Build a virtual DOM from the base snapshot\n  // 2. Apply each incremental mutation between base and target time\n  // 3. Serialize the resulting DOM back to a full snapshot\n\n  // For now, this simplified approach should work for most cases\n  console.log(`Created synthetic snapshot for time ${targetTimestamp}ms`);\n  return syntheticSnapshot;\n}\n\n/**\n * Cuts an rrweb recording to show only events within a specific time range\n * @param {Array} events - Original rrweb events array\n * @param {number} centerTimeSeconds - Relative time in seconds from start of recording\n * @param {number} beforeSeconds - Seconds to include before the center time (default: 5)\n * @param {number} afterSeconds - Seconds to include after the center time (default: 5)\n * @returns {Array} New rrweb events array for the clipped recording\n */\nexport function cutRecording(events, centerTimeSeconds, beforeSeconds = 5, afterSeconds = 5) {\n  if (!events || !Array.isArray(events) || events.length === 0) {\n    throw new Error(\"Invalid events array provided\");\n  }\n\n  // Convert relative time to absolute timestamp\n  const centerTimestamp = relativeTimeToTimestamp(events, centerTimeSeconds);\n  const beforeMs = beforeSeconds * 1000;\n  const afterMs = afterSeconds * 1000;\n  const startTime = centerTimestamp - beforeMs;\n  const endTime = centerTimestamp + afterMs;\n  console.log(`Cutting recording around ${formatTime(centerTimeSeconds)} (${centerTimeSeconds}s)`);\n  console.log(`Time range: ${formatTime(centerTimeSeconds - beforeSeconds)} to ${formatTime(centerTimeSeconds + afterSeconds)}`);\n\n  // Find the full snapshot that's closest to our cut time (before or after)\n  let fullSnapshot = null;\n  let bestDistance = Infinity;\n  for (const event of events) {\n    if (event.type === 2) {\n      const distance = Math.abs(event.timestamp - startTime);\n      if (distance < bestDistance) {\n        fullSnapshot = event;\n        bestDistance = distance;\n      }\n    }\n  }\n  if (!fullSnapshot) {\n    throw new Error(\"No full snapshot found in recording\");\n  }\n  console.log(`Using full snapshot at ${fullSnapshot.timestamp}, distance from cut: ${bestDistance}ms`);\n\n  // If the full snapshot is after our start time, we need to adjust our approach\n  if (fullSnapshot.timestamp > startTime) {\n    console.log(\"Full snapshot is after cut time, including events from start to snapshot\");\n  }\n\n  // Take a much more conservative approach: include ALL events\n  // from the closest full snapshot through our entire clip range\n  const snapshotTime = fullSnapshot.timestamp;\n  const rangeStart = Math.min(snapshotTime, startTime);\n  const rangeEnd = endTime;\n\n  // Get all events in the complete range we need\n  const neededEvents = events.filter(event => {\n    return event.timestamp >= rangeStart && event.timestamp <= rangeEnd;\n  });\n\n  // Create the new events array, ALWAYS starting with the full snapshot\n  const newEvents = [];\n\n  // Always add the full snapshot first\n  newEvents.push({\n    ...fullSnapshot,\n    timestamp: fullSnapshot.timestamp\n  });\n\n  // Add all other needed events (excluding the original full snapshot to avoid duplication)\n  for (const event of neededEvents) {\n    if (event.timestamp !== fullSnapshot.timestamp || event.type !== 2) {\n      newEvents.push({\n        ...event,\n        timestamp: event.timestamp\n      });\n    }\n  }\n\n  // Ensure we have at least 2 events total\n  if (newEvents.length < 2) {\n    const lastTimestamp = newEvents[newEvents.length - 1].timestamp;\n    newEvents.push({\n      type: 4,\n      // Meta event\n      data: {\n        href: window.location.href\n      },\n      timestamp: lastTimestamp + 100\n    });\n  }\n\n  // Sort by timestamp to ensure proper order\n  newEvents.sort((a, b) => a.timestamp - b.timestamp);\n  console.log(`Original recording: ${events.length} events`);\n  console.log(`Clipped recording: ${newEvents.length} events`);\n  console.log(`Time span: ${beforeSeconds + afterSeconds} seconds`);\n\n  // Debug: Check if we have full snapshots in the result\n  const resultSnapshots = newEvents.filter(e => e.type === 2);\n  console.log(`Full snapshots in result: ${resultSnapshots.length}`);\n  if (resultSnapshots.length === 0) {\n    console.error(\"WARNING: No full snapshots in cut result!\");\n    console.log(\"Original full snapshot timestamp:\", fullSnapshot.timestamp);\n    console.log(\"Range start:\", rangeStart, \"Range end:\", rangeEnd);\n    console.log(\"Events added:\", newEvents.map(e => ({\n      type: e.type,\n      timestamp: e.timestamp\n    })));\n  }\n  return newEvents;\n}\n\n/**\n * Finds all events of a specific type within a recording\n * @param {Array} events - rrweb events array\n * @param {number} eventType - Event type to search for (1=DOM, 2=FullSnapshot, 3=IncrementalSnapshot, etc.)\n * @returns {Array} Array of events matching the type\n */\nexport function findEventsByType(events, eventType) {\n  return events.filter(event => event.type === eventType);\n}\n\n/**\n * Finds events containing specific text or attributes\n * @param {Array} events - rrweb events array\n * @param {string} searchTerm - Text to search for\n * @returns {Array} Array of events containing the search term\n */\nexport function findEventsByContent(events, searchTerm) {\n  const matchingEvents = [];\n  for (const event of events) {\n    const eventStr = JSON.stringify(event).toLowerCase();\n    if (eventStr.includes(searchTerm.toLowerCase())) {\n      matchingEvents.push(event);\n    }\n  }\n  return matchingEvents;\n}\n\n/**\n * Analyzes a recording and provides statistics\n * @param {Array} events - rrweb events array\n * @returns {Object} Recording statistics\n */\nexport function analyzeRecording(events) {\n  if (!events || !Array.isArray(events) || events.length === 0) {\n    return null;\n  }\n  const firstTimestamp = events[0].timestamp;\n  const lastTimestamp = events[events.length - 1].timestamp;\n  const duration = (lastTimestamp - firstTimestamp) / 1000; // in seconds\n\n  const eventTypeCounts = {};\n  for (const event of events) {\n    eventTypeCounts[event.type] = (eventTypeCounts[event.type] || 0) + 1;\n  }\n  return {\n    totalEvents: events.length,\n    duration: duration,\n    startTime: firstTimestamp,\n    endTime: lastTimestamp,\n    eventTypeCounts: eventTypeCounts,\n    eventTypes: {\n      1: \"DomContentLoaded\",\n      2: \"FullSnapshot\",\n      3: \"IncrementalSnapshot\",\n      4: \"Meta\",\n      5: \"Custom\",\n      6: \"Plugin\"\n    }\n  };\n}\n\n/**\n * Creates multiple clips around specified timestamps\n * @param {Array} events - Original rrweb events array\n * @param {Array} timestamps - Array of timestamps to create clips around\n * @param {number} beforeSeconds - Seconds before each timestamp\n * @param {number} afterSeconds - Seconds after each timestamp\n * @returns {Array} Array of clipped recordings\n */\nexport function createMultipleClips(events, timestamps, beforeSeconds = 5, afterSeconds = 5) {\n  const clips = [];\n  for (let i = 0; i < timestamps.length; i++) {\n    const timestamp = timestamps[i];\n    try {\n      const clip = cutRecording(events, timestamp, beforeSeconds, afterSeconds);\n      clips.push({\n        index: i,\n        centerTimestamp: timestamp,\n        events: clip,\n        duration: beforeSeconds + afterSeconds\n      });\n    } catch (error) {\n      console.error(`Failed to create clip ${i} around timestamp ${timestamp}:`, error);\n    }\n  }\n  return clips;\n}\n\n/**\n * Trims a recording to keep only events within a specific time range\n * @param {Array} events - Original rrweb events array\n * @param {number} startMs - Start time in milliseconds\n * @param {number} endMs - End time in milliseconds\n * @returns {Array} New rrweb events array for the trimmed recording\n */\nexport function trimRecording(events, startMs, endMs) {\n  if (!events || !Array.isArray(events) || events.length === 0) {\n    throw new Error(\"Invalid events array provided\");\n  }\n  console.log(`Trimming recording from ${startMs}ms to ${endMs}ms`);\n\n  // Create a synthetic full snapshot at the exact start time\n  const syntheticSnapshot = createSyntheticSnapshot(events, startMs);\n\n  // Get all events within our trim range\n  const eventsInRange = events.filter(event => {\n    return event.timestamp >= startMs && event.timestamp <= endMs;\n  });\n\n  // Build the new events array\n  const newEvents = [];\n\n  // Always start with our synthetic full snapshot\n  newEvents.push(syntheticSnapshot);\n\n  // Add all events within the range (excluding any full snapshots)\n  for (const event of eventsInRange) {\n    // Skip full snapshots - we already have our synthetic one\n    if (event.type === 2) {\n      continue;\n    }\n\n    // Add the event as-is\n    newEvents.push({\n      ...event,\n      timestamp: event.timestamp\n    });\n  }\n\n  // If we only have the synthetic snapshot, add at least one more event\n  if (newEvents.length === 1) {\n    // Add a meta event to ensure we have at least 2 events\n    newEvents.push({\n      type: 4,\n      // Meta event\n      data: {\n        href: typeof window !== \"undefined\" ? window.location.href : \"\",\n        width: 1920,\n        height: 1080\n      },\n      timestamp: startMs + 1\n    });\n  }\n\n  // Sort by timestamp to ensure proper order\n  newEvents.sort((a, b) => a.timestamp - b.timestamp);\n  console.log(`Original recording: ${events.length} events`);\n  console.log(`Trimmed recording: ${newEvents.length} events`);\n  console.log(`Time range: ${(endMs - startMs) / 1000} seconds`);\n  return newEvents;\n}","map":{"version":3,"names":["relativeTimeToTimestamp","events","relativeSeconds","length","startTime","timestamp","timestampToRelativeTime","formatTime","seconds","hours","Math","floor","minutes","secs","toString","padStart","parseTimeString","timeStr","test","parseInt","parts","split","map","Number","createSyntheticSnapshot","targetTimestamp","console","log","baseSnapshot","event","type","find","e","Error","syntheticSnapshot","JSON","parse","stringify","cutRecording","centerTimeSeconds","beforeSeconds","afterSeconds","Array","isArray","centerTimestamp","beforeMs","afterMs","endTime","fullSnapshot","bestDistance","Infinity","distance","abs","snapshotTime","rangeStart","min","rangeEnd","neededEvents","filter","newEvents","push","lastTimestamp","data","href","window","location","sort","a","b","resultSnapshots","error","findEventsByType","eventType","findEventsByContent","searchTerm","matchingEvents","eventStr","toLowerCase","includes","analyzeRecording","firstTimestamp","duration","eventTypeCounts","totalEvents","eventTypes","createMultipleClips","timestamps","clips","i","clip","index","trimRecording","startMs","endMs","eventsInRange","width","height"],"sources":["/Users/ogonen/rrweb/src/RecordingCutter.js"],"sourcesContent":["// RecordingCutter.js - Utility for cutting rrweb recordings into smaller clips\n\n/**\n * Converts relative seconds to absolute timestamp\n * @param {Array} events - rrweb events array\n * @param {number} relativeSeconds - Seconds from start of recording\n * @returns {number} Absolute timestamp\n */\nexport function relativeTimeToTimestamp(events, relativeSeconds) {\n  if (!events || events.length === 0) return 0;\n  const startTime = events[0].timestamp;\n  return startTime + relativeSeconds * 1000;\n}\n\n/**\n * Converts absolute timestamp to relative seconds\n * @param {Array} events - rrweb events array\n * @param {number} timestamp - Absolute timestamp\n * @returns {number} Relative seconds from start\n */\nexport function timestampToRelativeTime(events, timestamp) {\n  if (!events || events.length === 0) return 0;\n  const startTime = events[0].timestamp;\n  return (timestamp - startTime) / 1000;\n}\n\n/**\n * Formats seconds as MM:SS or HH:MM:SS\n * @param {number} seconds - Total seconds\n * @returns {string} Formatted time string\n */\nexport function formatTime(seconds) {\n  const hours = Math.floor(seconds / 3600);\n  const minutes = Math.floor((seconds % 3600) / 60);\n  const secs = Math.floor(seconds % 60);\n\n  if (hours > 0) {\n    return `${hours}:${minutes.toString().padStart(2, \"0\")}:${secs\n      .toString()\n      .padStart(2, \"0\")}`;\n  }\n  return `${minutes}:${secs.toString().padStart(2, \"0\")}`;\n}\n\n/**\n * Parses time string (MM:SS, HH:MM:SS, or just seconds) to total seconds\n * @param {string} timeStr - Time string like \"1:30\", \"0:05\", \"90\", etc.\n * @returns {number} Total seconds\n */\nexport function parseTimeString(timeStr) {\n  if (!timeStr) return 0;\n\n  // If it's just a number, treat as seconds\n  if (/^\\d+$/.test(timeStr)) {\n    return parseInt(timeStr);\n  }\n\n  // Parse MM:SS or HH:MM:SS format\n  const parts = timeStr.split(\":\").map(Number);\n  if (parts.length === 2) {\n    // MM:SS\n    return parts[0] * 60 + parts[1];\n  } else if (parts.length === 3) {\n    // HH:MM:SS\n    return parts[0] * 3600 + parts[1] * 60 + parts[2];\n  }\n\n  return 0;\n}\n\n/**\n * Creates a synthetic full snapshot by replaying the recording up to a specific point\n * @param {Array} events - Original rrweb events array\n * @param {number} targetTimestamp - The timestamp to build the DOM state up to\n * @returns {Object} Synthetic full snapshot representing the DOM state at targetTimestamp\n */\nfunction createSyntheticSnapshot(events, targetTimestamp) {\n  console.log(`Creating synthetic full snapshot at ${targetTimestamp}ms`);\n\n  // Find the last full snapshot before our target time\n  let baseSnapshot = null;\n  for (const event of events) {\n    if (event.type === 2 && event.timestamp <= targetTimestamp) {\n      if (!baseSnapshot || event.timestamp > baseSnapshot.timestamp) {\n        baseSnapshot = event;\n      }\n    }\n  }\n\n  if (!baseSnapshot) {\n    // No full snapshot before target - use the first one\n    baseSnapshot = events.find((e) => e.type === 2);\n    if (!baseSnapshot) {\n      throw new Error(\"No full snapshot found in recording\");\n    }\n  }\n\n  console.log(`Found base snapshot at ${baseSnapshot.timestamp}ms`);\n\n  // Deep clone the base snapshot\n  const syntheticSnapshot = JSON.parse(JSON.stringify(baseSnapshot));\n  syntheticSnapshot.timestamp = targetTimestamp;\n\n  // To properly apply incremental changes, we would need rrweb's internal\n  // DOM reconstruction logic. For now, we'll return the base snapshot at the new time.\n  // This approach preserves the DOM structure while adjusting timing.\n\n  // In a full implementation, we would:\n  // 1. Build a virtual DOM from the base snapshot\n  // 2. Apply each incremental mutation between base and target time\n  // 3. Serialize the resulting DOM back to a full snapshot\n\n  // For now, this simplified approach should work for most cases\n  console.log(`Created synthetic snapshot for time ${targetTimestamp}ms`);\n\n  return syntheticSnapshot;\n}\n\n/**\n * Cuts an rrweb recording to show only events within a specific time range\n * @param {Array} events - Original rrweb events array\n * @param {number} centerTimeSeconds - Relative time in seconds from start of recording\n * @param {number} beforeSeconds - Seconds to include before the center time (default: 5)\n * @param {number} afterSeconds - Seconds to include after the center time (default: 5)\n * @returns {Array} New rrweb events array for the clipped recording\n */\nexport function cutRecording(\n  events,\n  centerTimeSeconds,\n  beforeSeconds = 5,\n  afterSeconds = 5\n) {\n  if (!events || !Array.isArray(events) || events.length === 0) {\n    throw new Error(\"Invalid events array provided\");\n  }\n\n  // Convert relative time to absolute timestamp\n  const centerTimestamp = relativeTimeToTimestamp(events, centerTimeSeconds);\n\n  const beforeMs = beforeSeconds * 1000;\n  const afterMs = afterSeconds * 1000;\n  const startTime = centerTimestamp - beforeMs;\n  const endTime = centerTimestamp + afterMs;\n\n  console.log(\n    `Cutting recording around ${formatTime(\n      centerTimeSeconds\n    )} (${centerTimeSeconds}s)`\n  );\n  console.log(\n    `Time range: ${formatTime(\n      centerTimeSeconds - beforeSeconds\n    )} to ${formatTime(centerTimeSeconds + afterSeconds)}`\n  );\n\n  // Find the full snapshot that's closest to our cut time (before or after)\n  let fullSnapshot = null;\n  let bestDistance = Infinity;\n\n  for (const event of events) {\n    if (event.type === 2) {\n      const distance = Math.abs(event.timestamp - startTime);\n      if (distance < bestDistance) {\n        fullSnapshot = event;\n        bestDistance = distance;\n      }\n    }\n  }\n\n  if (!fullSnapshot) {\n    throw new Error(\"No full snapshot found in recording\");\n  }\n\n  console.log(\n    `Using full snapshot at ${fullSnapshot.timestamp}, distance from cut: ${bestDistance}ms`\n  );\n\n  // If the full snapshot is after our start time, we need to adjust our approach\n  if (fullSnapshot.timestamp > startTime) {\n    console.log(\n      \"Full snapshot is after cut time, including events from start to snapshot\"\n    );\n  }\n\n  // Take a much more conservative approach: include ALL events\n  // from the closest full snapshot through our entire clip range\n  const snapshotTime = fullSnapshot.timestamp;\n  const rangeStart = Math.min(snapshotTime, startTime);\n  const rangeEnd = endTime;\n\n  // Get all events in the complete range we need\n  const neededEvents = events.filter((event) => {\n    return event.timestamp >= rangeStart && event.timestamp <= rangeEnd;\n  });\n\n  // Create the new events array, ALWAYS starting with the full snapshot\n  const newEvents = [];\n\n  // Always add the full snapshot first\n  newEvents.push({\n    ...fullSnapshot,\n    timestamp: fullSnapshot.timestamp,\n  });\n\n  // Add all other needed events (excluding the original full snapshot to avoid duplication)\n  for (const event of neededEvents) {\n    if (event.timestamp !== fullSnapshot.timestamp || event.type !== 2) {\n      newEvents.push({\n        ...event,\n        timestamp: event.timestamp,\n      });\n    }\n  }\n\n  // Ensure we have at least 2 events total\n  if (newEvents.length < 2) {\n    const lastTimestamp = newEvents[newEvents.length - 1].timestamp;\n    newEvents.push({\n      type: 4, // Meta event\n      data: { href: window.location.href },\n      timestamp: lastTimestamp + 100,\n    });\n  }\n\n  // Sort by timestamp to ensure proper order\n  newEvents.sort((a, b) => a.timestamp - b.timestamp);\n\n  console.log(`Original recording: ${events.length} events`);\n  console.log(`Clipped recording: ${newEvents.length} events`);\n  console.log(`Time span: ${beforeSeconds + afterSeconds} seconds`);\n\n  // Debug: Check if we have full snapshots in the result\n  const resultSnapshots = newEvents.filter((e) => e.type === 2);\n  console.log(`Full snapshots in result: ${resultSnapshots.length}`);\n\n  if (resultSnapshots.length === 0) {\n    console.error(\"WARNING: No full snapshots in cut result!\");\n    console.log(\"Original full snapshot timestamp:\", fullSnapshot.timestamp);\n    console.log(\"Range start:\", rangeStart, \"Range end:\", rangeEnd);\n    console.log(\n      \"Events added:\",\n      newEvents.map((e) => ({ type: e.type, timestamp: e.timestamp }))\n    );\n  }\n\n  return newEvents;\n}\n\n/**\n * Finds all events of a specific type within a recording\n * @param {Array} events - rrweb events array\n * @param {number} eventType - Event type to search for (1=DOM, 2=FullSnapshot, 3=IncrementalSnapshot, etc.)\n * @returns {Array} Array of events matching the type\n */\nexport function findEventsByType(events, eventType) {\n  return events.filter((event) => event.type === eventType);\n}\n\n/**\n * Finds events containing specific text or attributes\n * @param {Array} events - rrweb events array\n * @param {string} searchTerm - Text to search for\n * @returns {Array} Array of events containing the search term\n */\nexport function findEventsByContent(events, searchTerm) {\n  const matchingEvents = [];\n\n  for (const event of events) {\n    const eventStr = JSON.stringify(event).toLowerCase();\n    if (eventStr.includes(searchTerm.toLowerCase())) {\n      matchingEvents.push(event);\n    }\n  }\n\n  return matchingEvents;\n}\n\n/**\n * Analyzes a recording and provides statistics\n * @param {Array} events - rrweb events array\n * @returns {Object} Recording statistics\n */\nexport function analyzeRecording(events) {\n  if (!events || !Array.isArray(events) || events.length === 0) {\n    return null;\n  }\n\n  const firstTimestamp = events[0].timestamp;\n  const lastTimestamp = events[events.length - 1].timestamp;\n  const duration = (lastTimestamp - firstTimestamp) / 1000; // in seconds\n\n  const eventTypeCounts = {};\n  for (const event of events) {\n    eventTypeCounts[event.type] = (eventTypeCounts[event.type] || 0) + 1;\n  }\n\n  return {\n    totalEvents: events.length,\n    duration: duration,\n    startTime: firstTimestamp,\n    endTime: lastTimestamp,\n    eventTypeCounts: eventTypeCounts,\n    eventTypes: {\n      1: \"DomContentLoaded\",\n      2: \"FullSnapshot\",\n      3: \"IncrementalSnapshot\",\n      4: \"Meta\",\n      5: \"Custom\",\n      6: \"Plugin\",\n    },\n  };\n}\n\n/**\n * Creates multiple clips around specified timestamps\n * @param {Array} events - Original rrweb events array\n * @param {Array} timestamps - Array of timestamps to create clips around\n * @param {number} beforeSeconds - Seconds before each timestamp\n * @param {number} afterSeconds - Seconds after each timestamp\n * @returns {Array} Array of clipped recordings\n */\nexport function createMultipleClips(\n  events,\n  timestamps,\n  beforeSeconds = 5,\n  afterSeconds = 5\n) {\n  const clips = [];\n\n  for (let i = 0; i < timestamps.length; i++) {\n    const timestamp = timestamps[i];\n    try {\n      const clip = cutRecording(events, timestamp, beforeSeconds, afterSeconds);\n      clips.push({\n        index: i,\n        centerTimestamp: timestamp,\n        events: clip,\n        duration: beforeSeconds + afterSeconds,\n      });\n    } catch (error) {\n      console.error(\n        `Failed to create clip ${i} around timestamp ${timestamp}:`,\n        error\n      );\n    }\n  }\n\n  return clips;\n}\n\n/**\n * Trims a recording to keep only events within a specific time range\n * @param {Array} events - Original rrweb events array\n * @param {number} startMs - Start time in milliseconds\n * @param {number} endMs - End time in milliseconds\n * @returns {Array} New rrweb events array for the trimmed recording\n */\nexport function trimRecording(events, startMs, endMs) {\n  if (!events || !Array.isArray(events) || events.length === 0) {\n    throw new Error(\"Invalid events array provided\");\n  }\n\n  console.log(`Trimming recording from ${startMs}ms to ${endMs}ms`);\n\n  // Create a synthetic full snapshot at the exact start time\n  const syntheticSnapshot = createSyntheticSnapshot(events, startMs);\n\n  // Get all events within our trim range\n  const eventsInRange = events.filter((event) => {\n    return event.timestamp >= startMs && event.timestamp <= endMs;\n  });\n\n  // Build the new events array\n  const newEvents = [];\n\n  // Always start with our synthetic full snapshot\n  newEvents.push(syntheticSnapshot);\n\n  // Add all events within the range (excluding any full snapshots)\n  for (const event of eventsInRange) {\n    // Skip full snapshots - we already have our synthetic one\n    if (event.type === 2) {\n      continue;\n    }\n\n    // Add the event as-is\n    newEvents.push({\n      ...event,\n      timestamp: event.timestamp,\n    });\n  }\n\n  // If we only have the synthetic snapshot, add at least one more event\n  if (newEvents.length === 1) {\n    // Add a meta event to ensure we have at least 2 events\n    newEvents.push({\n      type: 4, // Meta event\n      data: {\n        href: typeof window !== \"undefined\" ? window.location.href : \"\",\n        width: 1920,\n        height: 1080,\n      },\n      timestamp: startMs + 1,\n    });\n  }\n\n  // Sort by timestamp to ensure proper order\n  newEvents.sort((a, b) => a.timestamp - b.timestamp);\n\n  console.log(`Original recording: ${events.length} events`);\n  console.log(`Trimmed recording: ${newEvents.length} events`);\n  console.log(`Time range: ${(endMs - startMs) / 1000} seconds`);\n\n  return newEvents;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}