{"ast":null,"code":"// RecordingCutter.js - Utility for cutting rrweb recordings into smaller clips\n\nimport { Replayer } from \"rrweb\";\nimport { snapshot } from \"rrweb-snapshot\";\n\n/**\n * Converts relative seconds to absolute timestamp\n * @param {Array} events - rrweb events array\n * @param {number} relativeSeconds - Seconds from start of recording\n * @returns {number} Absolute timestamp\n */\nexport function relativeTimeToTimestamp(events, relativeSeconds) {\n  if (!events || events.length === 0) return 0;\n  const startTime = events[0].timestamp;\n  return startTime + relativeSeconds * 1000;\n}\n\n/**\n * Converts absolute timestamp to relative seconds\n * @param {Array} events - rrweb events array\n * @param {number} timestamp - Absolute timestamp\n * @returns {number} Relative seconds from start\n */\nexport function timestampToRelativeTime(events, timestamp) {\n  if (!events || events.length === 0) return 0;\n  const startTime = events[0].timestamp;\n  return (timestamp - startTime) / 1000;\n}\n\n/**\n * Formats seconds as MM:SS or HH:MM:SS\n * @param {number} seconds - Total seconds\n * @returns {string} Formatted time string\n */\nexport function formatTime(seconds) {\n  const hours = Math.floor(seconds / 3600);\n  const minutes = Math.floor(seconds % 3600 / 60);\n  const secs = Math.floor(seconds % 60);\n  if (hours > 0) {\n    return `${hours}:${minutes.toString().padStart(2, \"0\")}:${secs.toString().padStart(2, \"0\")}`;\n  }\n  return `${minutes}:${secs.toString().padStart(2, \"0\")}`;\n}\n\n/**\n * Parses time string (MM:SS, HH:MM:SS, or just seconds) to total seconds\n * @param {string} timeStr - Time string like \"1:30\", \"0:05\", \"90\", etc.\n * @returns {number} Total seconds\n */\nexport function parseTimeString(timeStr) {\n  if (!timeStr) return 0;\n\n  // If it's just a number, treat as seconds\n  if (/^\\d+$/.test(timeStr)) {\n    return parseInt(timeStr);\n  }\n\n  // Parse MM:SS or HH:MM:SS format\n  const parts = timeStr.split(\":\").map(Number);\n  if (parts.length === 2) {\n    // MM:SS\n    return parts[0] * 60 + parts[1];\n  } else if (parts.length === 3) {\n    // HH:MM:SS\n    return parts[0] * 3600 + parts[1] * 60 + parts[2];\n  }\n  return 0;\n}\n\n/**\n * Creates a synthetic full snapshot by replaying the recording up to a specific point\n * @param {Array} events - Original rrweb events array\n * @param {number} targetTimestamp - The timestamp to build the DOM state up to\n * @returns {Object} Synthetic full snapshot representing the DOM state at targetTimestamp\n */\nfunction createSyntheticSnapshot(events, targetTimestamp) {\n  console.log(`Creating synthetic full snapshot at ${targetTimestamp}ms`);\n\n  // Find all full snapshots\n  const fullSnapshots = events.filter(e => e.type === 2).sort((a, b) => a.timestamp - b.timestamp);\n  if (fullSnapshots.length === 0) {\n    throw new Error(\"No full snapshot found in recording\");\n  }\n\n  // Find the best base snapshot\n  let baseSnapshot = null;\n  let nextSnapshot = null;\n  for (let i = 0; i < fullSnapshots.length; i++) {\n    if (fullSnapshots[i].timestamp <= targetTimestamp) {\n      baseSnapshot = fullSnapshots[i];\n      if (i < fullSnapshots.length - 1) {\n        nextSnapshot = fullSnapshots[i + 1];\n      }\n    } else {\n      break;\n    }\n  }\n\n  // If no snapshot before target, use the first one\n  if (!baseSnapshot) {\n    baseSnapshot = fullSnapshots[0];\n  }\n  console.log(`Found base snapshot at ${baseSnapshot.timestamp}ms`);\n  if (nextSnapshot) {\n    console.log(`Next snapshot at ${nextSnapshot.timestamp}ms`);\n  }\n\n  // Deep clone the base snapshot\n  const syntheticSnapshot = JSON.parse(JSON.stringify(baseSnapshot));\n\n  // Update the timestamp to match our target\n  syntheticSnapshot.timestamp = targetTimestamp;\n\n  // Ensure the synthetic snapshot has all required properties\n  if (!syntheticSnapshot.data) {\n    syntheticSnapshot.data = {};\n  }\n\n  // Make sure we have the basic structure\n  if (!syntheticSnapshot.data.node) {\n    console.warn(\"Base snapshot missing node data, using minimal structure\");\n    syntheticSnapshot.data.node = {\n      type: 0,\n      // Document node\n      childNodes: [],\n      id: 1\n    };\n  }\n\n  // Ensure we have required metadata\n  if (!syntheticSnapshot.data.href && typeof window !== \"undefined\") {\n    syntheticSnapshot.data.href = window.location.href;\n  }\n  console.log(`Created synthetic snapshot for time ${targetTimestamp}ms`);\n  return syntheticSnapshot;\n}\n\n/**\n * Cuts an rrweb recording to show only events within a specific time range\n * @param {Array} events - Original rrweb events array\n * @param {number} centerTimeSeconds - Relative time in seconds from start of recording\n * @param {number} beforeSeconds - Seconds to include before the center time (default: 5)\n * @param {number} afterSeconds - Seconds to include after the center time (default: 5)\n * @returns {Array} New rrweb events array for the clipped recording\n */\nexport function cutRecording(events, centerTimeSeconds, beforeSeconds = 5, afterSeconds = 5) {\n  if (!events || !Array.isArray(events) || events.length === 0) {\n    throw new Error(\"Invalid events array provided\");\n  }\n\n  // Convert relative time to absolute timestamp\n  const centerTimestamp = relativeTimeToTimestamp(events, centerTimeSeconds);\n  const beforeMs = beforeSeconds * 1000;\n  const afterMs = afterSeconds * 1000;\n  const startTime = centerTimestamp - beforeMs;\n  const endTime = centerTimestamp + afterMs;\n  console.log(`Cutting recording around ${formatTime(centerTimeSeconds)} (${centerTimeSeconds}s)`);\n  console.log(`Time range: ${formatTime(centerTimeSeconds - beforeSeconds)} to ${formatTime(centerTimeSeconds + afterSeconds)}`);\n\n  // Find the full snapshot that's closest to our cut time (before or after)\n  let fullSnapshot = null;\n  let bestDistance = Infinity;\n  for (const event of events) {\n    if (event.type === 2) {\n      const distance = Math.abs(event.timestamp - startTime);\n      if (distance < bestDistance) {\n        fullSnapshot = event;\n        bestDistance = distance;\n      }\n    }\n  }\n  if (!fullSnapshot) {\n    throw new Error(\"No full snapshot found in recording\");\n  }\n  console.log(`Using full snapshot at ${fullSnapshot.timestamp}, distance from cut: ${bestDistance}ms`);\n\n  // If the full snapshot is after our start time, we need to adjust our approach\n  if (fullSnapshot.timestamp > startTime) {\n    console.log(\"Full snapshot is after cut time, including events from start to snapshot\");\n  }\n\n  // Take a much more conservative approach: include ALL events\n  // from the closest full snapshot through our entire clip range\n  const snapshotTime = fullSnapshot.timestamp;\n  const rangeStart = Math.min(snapshotTime, startTime);\n  const rangeEnd = endTime;\n\n  // Get all events in the complete range we need\n  const neededEvents = events.filter(event => {\n    return event.timestamp >= rangeStart && event.timestamp <= rangeEnd;\n  });\n\n  // Create the new events array, ALWAYS starting with the full snapshot\n  const newEvents = [];\n\n  // Always add the full snapshot first\n  newEvents.push({\n    ...fullSnapshot,\n    timestamp: fullSnapshot.timestamp\n  });\n\n  // Add all other needed events (excluding the original full snapshot to avoid duplication)\n  for (const event of neededEvents) {\n    if (event.timestamp !== fullSnapshot.timestamp || event.type !== 2) {\n      newEvents.push({\n        ...event,\n        timestamp: event.timestamp\n      });\n    }\n  }\n\n  // Ensure we have at least 2 events total\n  if (newEvents.length < 2) {\n    const lastTimestamp = newEvents[newEvents.length - 1].timestamp;\n    newEvents.push({\n      type: 4,\n      // Meta event\n      data: {\n        href: window.location.href\n      },\n      timestamp: lastTimestamp + 100\n    });\n  }\n\n  // Sort by timestamp to ensure proper order\n  newEvents.sort((a, b) => a.timestamp - b.timestamp);\n  console.log(`Original recording: ${events.length} events`);\n  console.log(`Clipped recording: ${newEvents.length} events`);\n  console.log(`Time span: ${beforeSeconds + afterSeconds} seconds`);\n\n  // Debug: Check if we have full snapshots in the result\n  const resultSnapshots = newEvents.filter(e => e.type === 2);\n  console.log(`Full snapshots in result: ${resultSnapshots.length}`);\n  if (resultSnapshots.length === 0) {\n    console.error(\"WARNING: No full snapshots in cut result!\");\n    console.log(\"Original full snapshot timestamp:\", fullSnapshot.timestamp);\n    console.log(\"Range start:\", rangeStart, \"Range end:\", rangeEnd);\n    console.log(\"Events added:\", newEvents.map(e => ({\n      type: e.type,\n      timestamp: e.timestamp\n    })));\n  }\n  return newEvents;\n}\n\n/**\n * Finds all events of a specific type within a recording\n * @param {Array} events - rrweb events array\n * @param {number} eventType - Event type to search for (1=DOM, 2=FullSnapshot, 3=IncrementalSnapshot, etc.)\n * @returns {Array} Array of events matching the type\n */\nexport function findEventsByType(events, eventType) {\n  return events.filter(event => event.type === eventType);\n}\n\n/**\n * Finds events containing specific text or attributes\n * @param {Array} events - rrweb events array\n * @param {string} searchTerm - Text to search for\n * @returns {Array} Array of events containing the search term\n */\nexport function findEventsByContent(events, searchTerm) {\n  const matchingEvents = [];\n  for (const event of events) {\n    const eventStr = JSON.stringify(event).toLowerCase();\n    if (eventStr.includes(searchTerm.toLowerCase())) {\n      matchingEvents.push(event);\n    }\n  }\n  return matchingEvents;\n}\n\n/**\n * Analyzes a recording and provides statistics\n * @param {Array} events - rrweb events array\n * @returns {Object} Recording statistics\n */\nexport function analyzeRecording(events) {\n  if (!events || !Array.isArray(events) || events.length === 0) {\n    return null;\n  }\n  const firstTimestamp = events[0].timestamp;\n  const lastTimestamp = events[events.length - 1].timestamp;\n  const duration = (lastTimestamp - firstTimestamp) / 1000; // in seconds\n\n  const eventTypeCounts = {};\n  for (const event of events) {\n    eventTypeCounts[event.type] = (eventTypeCounts[event.type] || 0) + 1;\n  }\n  return {\n    totalEvents: events.length,\n    duration: duration,\n    startTime: firstTimestamp,\n    endTime: lastTimestamp,\n    eventTypeCounts: eventTypeCounts,\n    eventTypes: {\n      1: \"DomContentLoaded\",\n      2: \"FullSnapshot\",\n      3: \"IncrementalSnapshot\",\n      4: \"Meta\",\n      5: \"Custom\",\n      6: \"Plugin\"\n    }\n  };\n}\n\n/**\n * Creates multiple clips around specified timestamps\n * @param {Array} events - Original rrweb events array\n * @param {Array} timestamps - Array of timestamps to create clips around\n * @param {number} beforeSeconds - Seconds before each timestamp\n * @param {number} afterSeconds - Seconds after each timestamp\n * @returns {Array} Array of clipped recordings\n */\nexport function createMultipleClips(events, timestamps, beforeSeconds = 5, afterSeconds = 5) {\n  const clips = [];\n  for (let i = 0; i < timestamps.length; i++) {\n    const timestamp = timestamps[i];\n    try {\n      const clip = cutRecording(events, timestamp, beforeSeconds, afterSeconds);\n      clips.push({\n        index: i,\n        centerTimestamp: timestamp,\n        events: clip,\n        duration: beforeSeconds + afterSeconds\n      });\n    } catch (error) {\n      console.error(`Failed to create clip ${i} around timestamp ${timestamp}:`, error);\n    }\n  }\n  return clips;\n}\n\n/**\n * Creates a true synthetic snapshot by replaying to a specific point and capturing DOM state\n * @param {Array} events - Original rrweb events array\n * @param {number} targetTimestamp - The timestamp to capture DOM state at\n * @returns {Promise<Object>} Synthetic full snapshot at the target timestamp\n */\nasync function createTrueSyntheticSnapshot(events, targetTimestamp) {\n  return new Promise((resolve, reject) => {\n    try {\n      // Create a hidden container for replay\n      const container = document.createElement(\"div\");\n      container.style.position = \"fixed\";\n      container.style.top = \"-9999px\";\n      container.style.left = \"-9999px\";\n      container.style.width = \"1920px\";\n      container.style.height = \"1080px\";\n      container.style.overflow = \"hidden\";\n      document.body.appendChild(container);\n      let snapshotTaken = false;\n\n      // Create replayer\n      const replayer = new Replayer(events, {\n        root: container,\n        skipInactive: false,\n        showWarning: false,\n        showDebug: false,\n        blockClass: \"rr-block\",\n        speed: 99999,\n        // Play as fast as possible\n        mouseTail: false,\n        triggerFocus: false,\n        UNSAFE_replayCanvas: false,\n        useVirtualDom: false\n      });\n\n      // Listen for when we reach our target time\n      replayer.on(\"state-change\", state => {\n        if (!snapshotTaken && replayer.getCurrentTime() >= targetTimestamp - events[0].timestamp) {\n          snapshotTaken = true;\n\n          // Pause at our target point\n          replayer.pause();\n\n          // Take a snapshot of the current DOM state\n          setTimeout(() => {\n            try {\n              const iframe = container.querySelector(\"iframe\");\n              if (iframe && iframe.contentDocument) {\n                var _events$find, _events$find$data;\n                const snapshotData = snapshot(iframe.contentDocument, {\n                  blockClass: \"rr-block\",\n                  blockSelector: null,\n                  maskTextClass: \"rr-mask\",\n                  maskTextSelector: null,\n                  inlineStylesheet: true,\n                  maskAllInputs: false,\n                  maskTextFn: undefined,\n                  slimDOM: false,\n                  dataURLOptions: {},\n                  inlineImages: false,\n                  recordCanvas: false,\n                  preserveWhiteSpace: true,\n                  onSerialize: undefined,\n                  onIframeLoad: undefined,\n                  iframeLoadTimeout: undefined,\n                  keepIframeSrcFn: () => false\n                });\n\n                // Clean up\n                replayer.destroy();\n                document.body.removeChild(container);\n\n                // Create the synthetic full snapshot event\n                const syntheticSnapshot = {\n                  type: 2,\n                  data: {\n                    node: snapshotData,\n                    initialOffset: {\n                      top: 0,\n                      left: 0\n                    },\n                    href: ((_events$find = events.find(e => e.type === 4)) === null || _events$find === void 0 ? void 0 : (_events$find$data = _events$find.data) === null || _events$find$data === void 0 ? void 0 : _events$find$data.href) || window.location.href\n                  },\n                  timestamp: targetTimestamp,\n                  tabId: events[0].tabId\n                };\n                resolve(syntheticSnapshot);\n              } else {\n                throw new Error(\"Could not access replay iframe\");\n              }\n            } catch (error) {\n              replayer.destroy();\n              document.body.removeChild(container);\n              reject(error);\n            }\n          }, 100); // Small delay to ensure DOM is fully rendered\n        }\n      });\n\n      // Handle errors\n      replayer.on(\"error\", error => {\n        if (!snapshotTaken) {\n          replayer.destroy();\n          document.body.removeChild(container);\n          reject(error);\n        }\n      });\n\n      // Start playing\n      replayer.play();\n\n      // Fallback timeout\n      setTimeout(() => {\n        if (!snapshotTaken) {\n          replayer.destroy();\n          document.body.removeChild(container);\n          reject(new Error(\"Timeout creating synthetic snapshot\"));\n        }\n      }, 30000); // 30 second timeout\n    } catch (error) {\n      reject(error);\n    }\n  });\n}\n\n/**\n * Trims a recording to keep only events within a specific time range\n * @param {Array} events - Original rrweb events array\n * @param {number} startMs - Start time in milliseconds (absolute timestamp)\n * @param {number} endMs - End time in milliseconds (absolute timestamp)\n * @returns {Array} New rrweb events array for the trimmed recording\n */\nexport async function trimRecording(events, startMs, endMs) {\n  if (!events || !Array.isArray(events) || events.length === 0) {\n    throw new Error(\"Invalid events array provided\");\n  }\n  console.log(`Trimming recording from ${startMs}ms to ${endMs}ms`);\n  console.log(`Duration to trim: ${(endMs - startMs) / 1000} seconds`);\n\n  // Validate time range\n  const recordingStart = events[0].timestamp;\n  const recordingEnd = events[events.length - 1].timestamp;\n  console.log(`Recording spans from ${recordingStart} to ${recordingEnd}`);\n  console.log(`Recording total duration: ${(recordingEnd - recordingStart) / 1000} seconds`);\n  if (startMs < recordingStart) {\n    console.warn(`Start time ${startMs}ms is before recording start ${recordingStart}ms, adjusting`);\n    startMs = recordingStart;\n  }\n  if (endMs > recordingEnd) {\n    console.warn(`End time ${endMs}ms is after recording end ${recordingEnd}ms, adjusting`);\n    endMs = recordingEnd;\n  }\n  if (startMs >= endMs) {\n    console.error(`Invalid time range: startMs=${startMs}, endMs=${endMs}`);\n    throw new Error(`Invalid time range: start time (${startMs}ms) must be before end time (${endMs}ms)`);\n  }\n  try {\n    // Create a true synthetic snapshot at the exact trim start point\n    console.log(`Creating synthetic snapshot at trim start point (${startMs}ms)...`);\n    const syntheticSnapshot = await createTrueSyntheticSnapshot(events, startMs);\n    console.log(`Synthetic snapshot created successfully`);\n\n    // Build the new events array\n    const newEvents = [];\n\n    // Start with our synthetic snapshot\n    newEvents.push(syntheticSnapshot);\n\n    // Add meta event\n    const metaEvent = events.find(e => e.type === 4);\n    if (metaEvent) {\n      newEvents.push({\n        ...metaEvent,\n        timestamp: startMs + 1\n      });\n    }\n\n    // Include only events within the trim range\n    const eventsInRange = events.filter(event => {\n      return event.timestamp > startMs && event.timestamp <= endMs;\n    });\n    console.log(`Found ${eventsInRange.length} events within trim range`);\n\n    // Add all events in range\n    for (const event of eventsInRange) {\n      newEvents.push(event);\n    }\n\n    // Sort by timestamp\n    newEvents.sort((a, b) => a.timestamp - b.timestamp);\n    console.log(`Original recording: ${events.length} events`);\n    console.log(`Trimmed recording: ${newEvents.length} events`);\n    return newEvents;\n  } catch (error) {\n    console.error('Failed to create synthetic snapshot:', error);\n\n    // Fallback to the old method if synthetic snapshot fails\n    console.log('Falling back to traditional trim method...');\n    return trimRecordingFallback(events, startMs, endMs);\n  }\n}\n\n// Keep the old implementation as a fallback\nfunction trimRecordingFallback(events, startMs, endMs) {\n  // Find ALL full snapshots and choose the best one\n  const fullSnapshots = [];\n  for (let i = 0; i < events.length; i++) {\n    if (events[i].type === 2) {\n      fullSnapshots.push({\n        snapshot: events[i],\n        index: i\n      });\n    }\n  }\n  if (fullSnapshots.length === 0) {\n    throw new Error(\"No full snapshot found in recording\");\n  }\n\n  // Find the best snapshot - prefer one close to but before the start time\n  let baseSnapshot = null;\n  let baseSnapshotIndex = -1;\n\n  // First, look for snapshots within 30 seconds before the trim start\n  const threshold = 30000; // 30 seconds in milliseconds\n  for (const {\n    snapshot,\n    index\n  } of fullSnapshots) {\n    if (snapshot.timestamp <= startMs && snapshot.timestamp >= startMs - threshold) {\n      baseSnapshot = snapshot;\n      baseSnapshotIndex = index;\n    }\n  }\n\n  // If no snapshot within threshold, find the closest one before start\n  if (!baseSnapshot) {\n    for (const {\n      snapshot,\n      index\n    } of fullSnapshots) {\n      if (snapshot.timestamp <= startMs) {\n        baseSnapshot = snapshot;\n        baseSnapshotIndex = index;\n      }\n    }\n  }\n\n  // If still no snapshot (trim starts before first snapshot), use the first one\n  if (!baseSnapshot) {\n    baseSnapshot = fullSnapshots[0].snapshot;\n    baseSnapshotIndex = fullSnapshots[0].index;\n  }\n  if (!baseSnapshot) {\n    throw new Error(\"No full snapshot found in recording\");\n  }\n  console.log(`Using base snapshot at index ${baseSnapshotIndex}, timestamp ${baseSnapshot.timestamp}ms`);\n  console.log(`Time from base snapshot to trim start: ${(startMs - baseSnapshot.timestamp) / 1000} seconds`);\n\n  // Build the new events array\n  const newEvents = [];\n\n  // IMPORTANT: We need to include the minimum set of events to reconstruct the DOM at startMs\n  // This means:\n  // 1. The base snapshot\n  // 2. All mutations from base snapshot to startMs (to build correct DOM state)\n  // 3. All events from startMs to endMs (the actual content we want)\n\n  // Add the base snapshot\n  newEvents.push({\n    ...baseSnapshot,\n    timestamp: baseSnapshot.timestamp\n  });\n\n  // Add meta event if we have one\n  const metaEvent = events.find(e => e.type === 4);\n  if (metaEvent) {\n    newEvents.push({\n      ...metaEvent,\n      timestamp: baseSnapshot.timestamp + 1\n    });\n  }\n\n  // Count events in different ranges for debugging\n  let eventsBeforeTrim = 0;\n  let eventsInTrim = 0;\n\n  // Include necessary events to reconstruct DOM state at startMs\n  // and all events within the trim range\n  for (let i = baseSnapshotIndex + 1; i < events.length; i++) {\n    const event = events[i];\n\n    // Stop if we've passed the end time\n    if (event.timestamp > endMs) {\n      break;\n    }\n\n    // Skip full snapshots - we already have our base\n    if (event.type === 2) {\n      continue;\n    }\n\n    // For events before the trim start, only include mutations\n    // that are necessary for DOM reconstruction\n    if (event.timestamp < startMs) {\n      // Only include incremental snapshots (mutations)\n      if (event.type === 3 && event.data && event.data.source === 0) {\n        newEvents.push(event);\n        eventsBeforeTrim++;\n      }\n    } else {\n      // Include all events within the trim range\n      newEvents.push(event);\n      eventsInTrim++;\n    }\n  }\n  console.log(`Events included before trim start: ${eventsBeforeTrim}`);\n  console.log(`Events included within trim range: ${eventsInTrim}`);\n\n  // Sort by timestamp to ensure proper order\n  newEvents.sort((a, b) => a.timestamp - b.timestamp);\n\n  // If we need at least 2 events and only have 1, add a minimal event\n  if (newEvents.length === 1) {\n    console.log(\"Only one event found, adding minimal event\");\n    newEvents.push({\n      type: 3,\n      // IncrementalSnapshot\n      data: {\n        source: 0,\n        // Mutation\n        texts: [],\n        attributes: [],\n        removes: [],\n        adds: []\n      },\n      timestamp: baseSnapshot.timestamp + 10\n    });\n  }\n\n  // IMPORTANT: Shift timestamps so playback starts at the trim point\n  // This makes the recording appear to start at the selected time\n  const timeShift = startMs - baseSnapshot.timestamp;\n  const baseTime = newEvents[0].timestamp;\n  console.log(`Time shift: ${timeShift / 1000} seconds`);\n  console.log(`Adjusting timestamps to start playback at trim point...`);\n\n  // Adjust all timestamps\n  const shiftedEvents = newEvents.map((event, index) => {\n    // Calculate relative time from base\n    const relativeTime = event.timestamp - baseTime;\n\n    // For events before the trim start, compress them into the first 100ms\n    // This ensures DOM is built quickly without showing long buildup\n    if (event.timestamp < startMs && event.type === 3 && event.data.source === 0) {\n      // Compress pre-trim mutations into first 100ms\n      const compressionRatio = Math.min(relativeTime / timeShift, 1);\n      return {\n        ...event,\n        timestamp: compressionRatio * 100\n      };\n    } else {\n      // For events at or after trim start, maintain relative timing\n      const newTimestamp = event.timestamp - startMs + 100;\n      return {\n        ...event,\n        timestamp: newTimestamp\n      };\n    }\n  });\n  console.log(`Original recording: ${events.length} events`);\n  console.log(`Trimmed recording: ${shiftedEvents.length} events`);\n  console.log(`Original time range: ${newEvents[0].timestamp}ms to ${newEvents[newEvents.length - 1].timestamp}ms`);\n  console.log(`Shifted time range: ${shiftedEvents[0].timestamp}ms to ${shiftedEvents[shiftedEvents.length - 1].timestamp}ms`);\n  console.log(`Requested trim range: ${startMs}ms to ${endMs}ms`);\n\n  // Validate we have at least 2 events\n  if (shiftedEvents.length < 2) {\n    throw new Error(`Trimmed recording has only ${shiftedEvents.length} events, need at least 2`);\n  }\n  return shiftedEvents;\n}","map":{"version":3,"names":["Replayer","snapshot","relativeTimeToTimestamp","events","relativeSeconds","length","startTime","timestamp","timestampToRelativeTime","formatTime","seconds","hours","Math","floor","minutes","secs","toString","padStart","parseTimeString","timeStr","test","parseInt","parts","split","map","Number","createSyntheticSnapshot","targetTimestamp","console","log","fullSnapshots","filter","e","type","sort","a","b","Error","baseSnapshot","nextSnapshot","i","syntheticSnapshot","JSON","parse","stringify","data","node","warn","childNodes","id","href","window","location","cutRecording","centerTimeSeconds","beforeSeconds","afterSeconds","Array","isArray","centerTimestamp","beforeMs","afterMs","endTime","fullSnapshot","bestDistance","Infinity","event","distance","abs","snapshotTime","rangeStart","min","rangeEnd","neededEvents","newEvents","push","lastTimestamp","resultSnapshots","error","findEventsByType","eventType","findEventsByContent","searchTerm","matchingEvents","eventStr","toLowerCase","includes","analyzeRecording","firstTimestamp","duration","eventTypeCounts","totalEvents","eventTypes","createMultipleClips","timestamps","clips","clip","index","createTrueSyntheticSnapshot","Promise","resolve","reject","container","document","createElement","style","position","top","left","width","height","overflow","body","appendChild","snapshotTaken","replayer","root","skipInactive","showWarning","showDebug","blockClass","speed","mouseTail","triggerFocus","UNSAFE_replayCanvas","useVirtualDom","on","state","getCurrentTime","pause","setTimeout","iframe","querySelector","contentDocument","_events$find","_events$find$data","snapshotData","blockSelector","maskTextClass","maskTextSelector","inlineStylesheet","maskAllInputs","maskTextFn","undefined","slimDOM","dataURLOptions","inlineImages","recordCanvas","preserveWhiteSpace","onSerialize","onIframeLoad","iframeLoadTimeout","keepIframeSrcFn","destroy","removeChild","initialOffset","find","tabId","play","trimRecording","startMs","endMs","recordingStart","recordingEnd","metaEvent","eventsInRange","trimRecordingFallback","baseSnapshotIndex","threshold","eventsBeforeTrim","eventsInTrim","source","texts","attributes","removes","adds","timeShift","baseTime","shiftedEvents","relativeTime","compressionRatio","newTimestamp"],"sources":["/Users/ogonen/rrweb/src/RecordingCutter.js"],"sourcesContent":["// RecordingCutter.js - Utility for cutting rrweb recordings into smaller clips\n\nimport { Replayer } from \"rrweb\";\nimport { snapshot } from \"rrweb-snapshot\";\n\n/**\n * Converts relative seconds to absolute timestamp\n * @param {Array} events - rrweb events array\n * @param {number} relativeSeconds - Seconds from start of recording\n * @returns {number} Absolute timestamp\n */\nexport function relativeTimeToTimestamp(events, relativeSeconds) {\n  if (!events || events.length === 0) return 0;\n  const startTime = events[0].timestamp;\n  return startTime + relativeSeconds * 1000;\n}\n\n/**\n * Converts absolute timestamp to relative seconds\n * @param {Array} events - rrweb events array\n * @param {number} timestamp - Absolute timestamp\n * @returns {number} Relative seconds from start\n */\nexport function timestampToRelativeTime(events, timestamp) {\n  if (!events || events.length === 0) return 0;\n  const startTime = events[0].timestamp;\n  return (timestamp - startTime) / 1000;\n}\n\n/**\n * Formats seconds as MM:SS or HH:MM:SS\n * @param {number} seconds - Total seconds\n * @returns {string} Formatted time string\n */\nexport function formatTime(seconds) {\n  const hours = Math.floor(seconds / 3600);\n  const minutes = Math.floor((seconds % 3600) / 60);\n  const secs = Math.floor(seconds % 60);\n\n  if (hours > 0) {\n    return `${hours}:${minutes.toString().padStart(2, \"0\")}:${secs\n      .toString()\n      .padStart(2, \"0\")}`;\n  }\n  return `${minutes}:${secs.toString().padStart(2, \"0\")}`;\n}\n\n/**\n * Parses time string (MM:SS, HH:MM:SS, or just seconds) to total seconds\n * @param {string} timeStr - Time string like \"1:30\", \"0:05\", \"90\", etc.\n * @returns {number} Total seconds\n */\nexport function parseTimeString(timeStr) {\n  if (!timeStr) return 0;\n\n  // If it's just a number, treat as seconds\n  if (/^\\d+$/.test(timeStr)) {\n    return parseInt(timeStr);\n  }\n\n  // Parse MM:SS or HH:MM:SS format\n  const parts = timeStr.split(\":\").map(Number);\n  if (parts.length === 2) {\n    // MM:SS\n    return parts[0] * 60 + parts[1];\n  } else if (parts.length === 3) {\n    // HH:MM:SS\n    return parts[0] * 3600 + parts[1] * 60 + parts[2];\n  }\n\n  return 0;\n}\n\n/**\n * Creates a synthetic full snapshot by replaying the recording up to a specific point\n * @param {Array} events - Original rrweb events array\n * @param {number} targetTimestamp - The timestamp to build the DOM state up to\n * @returns {Object} Synthetic full snapshot representing the DOM state at targetTimestamp\n */\nfunction createSyntheticSnapshot(events, targetTimestamp) {\n  console.log(`Creating synthetic full snapshot at ${targetTimestamp}ms`);\n\n  // Find all full snapshots\n  const fullSnapshots = events\n    .filter((e) => e.type === 2)\n    .sort((a, b) => a.timestamp - b.timestamp);\n\n  if (fullSnapshots.length === 0) {\n    throw new Error(\"No full snapshot found in recording\");\n  }\n\n  // Find the best base snapshot\n  let baseSnapshot = null;\n  let nextSnapshot = null;\n\n  for (let i = 0; i < fullSnapshots.length; i++) {\n    if (fullSnapshots[i].timestamp <= targetTimestamp) {\n      baseSnapshot = fullSnapshots[i];\n      if (i < fullSnapshots.length - 1) {\n        nextSnapshot = fullSnapshots[i + 1];\n      }\n    } else {\n      break;\n    }\n  }\n\n  // If no snapshot before target, use the first one\n  if (!baseSnapshot) {\n    baseSnapshot = fullSnapshots[0];\n  }\n\n  console.log(`Found base snapshot at ${baseSnapshot.timestamp}ms`);\n  if (nextSnapshot) {\n    console.log(`Next snapshot at ${nextSnapshot.timestamp}ms`);\n  }\n\n  // Deep clone the base snapshot\n  const syntheticSnapshot = JSON.parse(JSON.stringify(baseSnapshot));\n\n  // Update the timestamp to match our target\n  syntheticSnapshot.timestamp = targetTimestamp;\n\n  // Ensure the synthetic snapshot has all required properties\n  if (!syntheticSnapshot.data) {\n    syntheticSnapshot.data = {};\n  }\n\n  // Make sure we have the basic structure\n  if (!syntheticSnapshot.data.node) {\n    console.warn(\"Base snapshot missing node data, using minimal structure\");\n    syntheticSnapshot.data.node = {\n      type: 0, // Document node\n      childNodes: [],\n      id: 1,\n    };\n  }\n\n  // Ensure we have required metadata\n  if (!syntheticSnapshot.data.href && typeof window !== \"undefined\") {\n    syntheticSnapshot.data.href = window.location.href;\n  }\n\n  console.log(`Created synthetic snapshot for time ${targetTimestamp}ms`);\n\n  return syntheticSnapshot;\n}\n\n/**\n * Cuts an rrweb recording to show only events within a specific time range\n * @param {Array} events - Original rrweb events array\n * @param {number} centerTimeSeconds - Relative time in seconds from start of recording\n * @param {number} beforeSeconds - Seconds to include before the center time (default: 5)\n * @param {number} afterSeconds - Seconds to include after the center time (default: 5)\n * @returns {Array} New rrweb events array for the clipped recording\n */\nexport function cutRecording(\n  events,\n  centerTimeSeconds,\n  beforeSeconds = 5,\n  afterSeconds = 5\n) {\n  if (!events || !Array.isArray(events) || events.length === 0) {\n    throw new Error(\"Invalid events array provided\");\n  }\n\n  // Convert relative time to absolute timestamp\n  const centerTimestamp = relativeTimeToTimestamp(events, centerTimeSeconds);\n\n  const beforeMs = beforeSeconds * 1000;\n  const afterMs = afterSeconds * 1000;\n  const startTime = centerTimestamp - beforeMs;\n  const endTime = centerTimestamp + afterMs;\n\n  console.log(\n    `Cutting recording around ${formatTime(\n      centerTimeSeconds\n    )} (${centerTimeSeconds}s)`\n  );\n  console.log(\n    `Time range: ${formatTime(\n      centerTimeSeconds - beforeSeconds\n    )} to ${formatTime(centerTimeSeconds + afterSeconds)}`\n  );\n\n  // Find the full snapshot that's closest to our cut time (before or after)\n  let fullSnapshot = null;\n  let bestDistance = Infinity;\n\n  for (const event of events) {\n    if (event.type === 2) {\n      const distance = Math.abs(event.timestamp - startTime);\n      if (distance < bestDistance) {\n        fullSnapshot = event;\n        bestDistance = distance;\n      }\n    }\n  }\n\n  if (!fullSnapshot) {\n    throw new Error(\"No full snapshot found in recording\");\n  }\n\n  console.log(\n    `Using full snapshot at ${fullSnapshot.timestamp}, distance from cut: ${bestDistance}ms`\n  );\n\n  // If the full snapshot is after our start time, we need to adjust our approach\n  if (fullSnapshot.timestamp > startTime) {\n    console.log(\n      \"Full snapshot is after cut time, including events from start to snapshot\"\n    );\n  }\n\n  // Take a much more conservative approach: include ALL events\n  // from the closest full snapshot through our entire clip range\n  const snapshotTime = fullSnapshot.timestamp;\n  const rangeStart = Math.min(snapshotTime, startTime);\n  const rangeEnd = endTime;\n\n  // Get all events in the complete range we need\n  const neededEvents = events.filter((event) => {\n    return event.timestamp >= rangeStart && event.timestamp <= rangeEnd;\n  });\n\n  // Create the new events array, ALWAYS starting with the full snapshot\n  const newEvents = [];\n\n  // Always add the full snapshot first\n  newEvents.push({\n    ...fullSnapshot,\n    timestamp: fullSnapshot.timestamp,\n  });\n\n  // Add all other needed events (excluding the original full snapshot to avoid duplication)\n  for (const event of neededEvents) {\n    if (event.timestamp !== fullSnapshot.timestamp || event.type !== 2) {\n      newEvents.push({\n        ...event,\n        timestamp: event.timestamp,\n      });\n    }\n  }\n\n  // Ensure we have at least 2 events total\n  if (newEvents.length < 2) {\n    const lastTimestamp = newEvents[newEvents.length - 1].timestamp;\n    newEvents.push({\n      type: 4, // Meta event\n      data: { href: window.location.href },\n      timestamp: lastTimestamp + 100,\n    });\n  }\n\n  // Sort by timestamp to ensure proper order\n  newEvents.sort((a, b) => a.timestamp - b.timestamp);\n\n  console.log(`Original recording: ${events.length} events`);\n  console.log(`Clipped recording: ${newEvents.length} events`);\n  console.log(`Time span: ${beforeSeconds + afterSeconds} seconds`);\n\n  // Debug: Check if we have full snapshots in the result\n  const resultSnapshots = newEvents.filter((e) => e.type === 2);\n  console.log(`Full snapshots in result: ${resultSnapshots.length}`);\n\n  if (resultSnapshots.length === 0) {\n    console.error(\"WARNING: No full snapshots in cut result!\");\n    console.log(\"Original full snapshot timestamp:\", fullSnapshot.timestamp);\n    console.log(\"Range start:\", rangeStart, \"Range end:\", rangeEnd);\n    console.log(\n      \"Events added:\",\n      newEvents.map((e) => ({ type: e.type, timestamp: e.timestamp }))\n    );\n  }\n\n  return newEvents;\n}\n\n/**\n * Finds all events of a specific type within a recording\n * @param {Array} events - rrweb events array\n * @param {number} eventType - Event type to search for (1=DOM, 2=FullSnapshot, 3=IncrementalSnapshot, etc.)\n * @returns {Array} Array of events matching the type\n */\nexport function findEventsByType(events, eventType) {\n  return events.filter((event) => event.type === eventType);\n}\n\n/**\n * Finds events containing specific text or attributes\n * @param {Array} events - rrweb events array\n * @param {string} searchTerm - Text to search for\n * @returns {Array} Array of events containing the search term\n */\nexport function findEventsByContent(events, searchTerm) {\n  const matchingEvents = [];\n\n  for (const event of events) {\n    const eventStr = JSON.stringify(event).toLowerCase();\n    if (eventStr.includes(searchTerm.toLowerCase())) {\n      matchingEvents.push(event);\n    }\n  }\n\n  return matchingEvents;\n}\n\n/**\n * Analyzes a recording and provides statistics\n * @param {Array} events - rrweb events array\n * @returns {Object} Recording statistics\n */\nexport function analyzeRecording(events) {\n  if (!events || !Array.isArray(events) || events.length === 0) {\n    return null;\n  }\n\n  const firstTimestamp = events[0].timestamp;\n  const lastTimestamp = events[events.length - 1].timestamp;\n  const duration = (lastTimestamp - firstTimestamp) / 1000; // in seconds\n\n  const eventTypeCounts = {};\n  for (const event of events) {\n    eventTypeCounts[event.type] = (eventTypeCounts[event.type] || 0) + 1;\n  }\n\n  return {\n    totalEvents: events.length,\n    duration: duration,\n    startTime: firstTimestamp,\n    endTime: lastTimestamp,\n    eventTypeCounts: eventTypeCounts,\n    eventTypes: {\n      1: \"DomContentLoaded\",\n      2: \"FullSnapshot\",\n      3: \"IncrementalSnapshot\",\n      4: \"Meta\",\n      5: \"Custom\",\n      6: \"Plugin\",\n    },\n  };\n}\n\n/**\n * Creates multiple clips around specified timestamps\n * @param {Array} events - Original rrweb events array\n * @param {Array} timestamps - Array of timestamps to create clips around\n * @param {number} beforeSeconds - Seconds before each timestamp\n * @param {number} afterSeconds - Seconds after each timestamp\n * @returns {Array} Array of clipped recordings\n */\nexport function createMultipleClips(\n  events,\n  timestamps,\n  beforeSeconds = 5,\n  afterSeconds = 5\n) {\n  const clips = [];\n\n  for (let i = 0; i < timestamps.length; i++) {\n    const timestamp = timestamps[i];\n    try {\n      const clip = cutRecording(events, timestamp, beforeSeconds, afterSeconds);\n      clips.push({\n        index: i,\n        centerTimestamp: timestamp,\n        events: clip,\n        duration: beforeSeconds + afterSeconds,\n      });\n    } catch (error) {\n      console.error(\n        `Failed to create clip ${i} around timestamp ${timestamp}:`,\n        error\n      );\n    }\n  }\n\n  return clips;\n}\n\n/**\n * Creates a true synthetic snapshot by replaying to a specific point and capturing DOM state\n * @param {Array} events - Original rrweb events array\n * @param {number} targetTimestamp - The timestamp to capture DOM state at\n * @returns {Promise<Object>} Synthetic full snapshot at the target timestamp\n */\nasync function createTrueSyntheticSnapshot(events, targetTimestamp) {\n  return new Promise((resolve, reject) => {\n    try {\n      // Create a hidden container for replay\n      const container = document.createElement(\"div\");\n      container.style.position = \"fixed\";\n      container.style.top = \"-9999px\";\n      container.style.left = \"-9999px\";\n      container.style.width = \"1920px\";\n      container.style.height = \"1080px\";\n      container.style.overflow = \"hidden\";\n      document.body.appendChild(container);\n\n      let snapshotTaken = false;\n\n      // Create replayer\n      const replayer = new Replayer(events, {\n        root: container,\n        skipInactive: false,\n        showWarning: false,\n        showDebug: false,\n        blockClass: \"rr-block\",\n        speed: 99999, // Play as fast as possible\n        mouseTail: false,\n        triggerFocus: false,\n        UNSAFE_replayCanvas: false,\n        useVirtualDom: false,\n      });\n\n      // Listen for when we reach our target time\n      replayer.on(\"state-change\", (state) => {\n        if (\n          !snapshotTaken &&\n          replayer.getCurrentTime() >= targetTimestamp - events[0].timestamp\n        ) {\n          snapshotTaken = true;\n\n          // Pause at our target point\n          replayer.pause();\n\n          // Take a snapshot of the current DOM state\n          setTimeout(() => {\n            try {\n              const iframe = container.querySelector(\"iframe\");\n              if (iframe && iframe.contentDocument) {\n                const snapshotData = snapshot(iframe.contentDocument, {\n                  blockClass: \"rr-block\",\n                  blockSelector: null,\n                  maskTextClass: \"rr-mask\",\n                  maskTextSelector: null,\n                  inlineStylesheet: true,\n                  maskAllInputs: false,\n                  maskTextFn: undefined,\n                  slimDOM: false,\n                  dataURLOptions: {},\n                  inlineImages: false,\n                  recordCanvas: false,\n                  preserveWhiteSpace: true,\n                  onSerialize: undefined,\n                  onIframeLoad: undefined,\n                  iframeLoadTimeout: undefined,\n                  keepIframeSrcFn: () => false,\n                });\n\n                // Clean up\n                replayer.destroy();\n                document.body.removeChild(container);\n\n                // Create the synthetic full snapshot event\n                const syntheticSnapshot = {\n                  type: 2,\n                  data: {\n                    node: snapshotData,\n                    initialOffset: { top: 0, left: 0 },\n                    href:\n                      events.find((e) => e.type === 4)?.data?.href ||\n                      window.location.href,\n                  },\n                  timestamp: targetTimestamp,\n                  tabId: events[0].tabId,\n                };\n\n                resolve(syntheticSnapshot);\n              } else {\n                throw new Error(\"Could not access replay iframe\");\n              }\n            } catch (error) {\n              replayer.destroy();\n              document.body.removeChild(container);\n              reject(error);\n            }\n          }, 100); // Small delay to ensure DOM is fully rendered\n        }\n      });\n\n      // Handle errors\n      replayer.on(\"error\", (error) => {\n        if (!snapshotTaken) {\n          replayer.destroy();\n          document.body.removeChild(container);\n          reject(error);\n        }\n      });\n\n      // Start playing\n      replayer.play();\n\n      // Fallback timeout\n      setTimeout(() => {\n        if (!snapshotTaken) {\n          replayer.destroy();\n          document.body.removeChild(container);\n          reject(new Error(\"Timeout creating synthetic snapshot\"));\n        }\n      }, 30000); // 30 second timeout\n    } catch (error) {\n      reject(error);\n    }\n  });\n}\n\n/**\n * Trims a recording to keep only events within a specific time range\n * @param {Array} events - Original rrweb events array\n * @param {number} startMs - Start time in milliseconds (absolute timestamp)\n * @param {number} endMs - End time in milliseconds (absolute timestamp)\n * @returns {Array} New rrweb events array for the trimmed recording\n */\nexport async function trimRecording(events, startMs, endMs) {\n  if (!events || !Array.isArray(events) || events.length === 0) {\n    throw new Error(\"Invalid events array provided\");\n  }\n\n  console.log(`Trimming recording from ${startMs}ms to ${endMs}ms`);\n  console.log(`Duration to trim: ${(endMs - startMs) / 1000} seconds`);\n\n  // Validate time range\n  const recordingStart = events[0].timestamp;\n  const recordingEnd = events[events.length - 1].timestamp;\n\n  console.log(`Recording spans from ${recordingStart} to ${recordingEnd}`);\n  console.log(\n    `Recording total duration: ${\n      (recordingEnd - recordingStart) / 1000\n    } seconds`\n  );\n\n  if (startMs < recordingStart) {\n    console.warn(\n      `Start time ${startMs}ms is before recording start ${recordingStart}ms, adjusting`\n    );\n    startMs = recordingStart;\n  }\n\n  if (endMs > recordingEnd) {\n    console.warn(\n      `End time ${endMs}ms is after recording end ${recordingEnd}ms, adjusting`\n    );\n    endMs = recordingEnd;\n  }\n\n  if (startMs >= endMs) {\n    console.error(`Invalid time range: startMs=${startMs}, endMs=${endMs}`);\n    throw new Error(\n      `Invalid time range: start time (${startMs}ms) must be before end time (${endMs}ms)`\n    );\n  }\n\n  try {\n    // Create a true synthetic snapshot at the exact trim start point\n    console.log(`Creating synthetic snapshot at trim start point (${startMs}ms)...`);\n    const syntheticSnapshot = await createTrueSyntheticSnapshot(events, startMs);\n    console.log(`Synthetic snapshot created successfully`);\n\n    // Build the new events array\n    const newEvents = [];\n\n    // Start with our synthetic snapshot\n    newEvents.push(syntheticSnapshot);\n\n    // Add meta event\n    const metaEvent = events.find((e) => e.type === 4);\n    if (metaEvent) {\n      newEvents.push({\n        ...metaEvent,\n        timestamp: startMs + 1,\n      });\n    }\n\n    // Include only events within the trim range\n    const eventsInRange = events.filter((event) => {\n      return event.timestamp > startMs && event.timestamp <= endMs;\n    });\n\n    console.log(`Found ${eventsInRange.length} events within trim range`);\n\n    // Add all events in range\n    for (const event of eventsInRange) {\n      newEvents.push(event);\n    }\n\n    // Sort by timestamp\n    newEvents.sort((a, b) => a.timestamp - b.timestamp);\n\n    console.log(`Original recording: ${events.length} events`);\n    console.log(`Trimmed recording: ${newEvents.length} events`);\n\n    return newEvents;\n\n  } catch (error) {\n    console.error('Failed to create synthetic snapshot:', error);\n    \n    // Fallback to the old method if synthetic snapshot fails\n    console.log('Falling back to traditional trim method...');\n    return trimRecordingFallback(events, startMs, endMs);\n  }\n}\n\n// Keep the old implementation as a fallback\nfunction trimRecordingFallback(events, startMs, endMs) {\n\n  // Find ALL full snapshots and choose the best one\n  const fullSnapshots = [];\n  for (let i = 0; i < events.length; i++) {\n    if (events[i].type === 2) {\n      fullSnapshots.push({ snapshot: events[i], index: i });\n    }\n  }\n\n  if (fullSnapshots.length === 0) {\n    throw new Error(\"No full snapshot found in recording\");\n  }\n\n  // Find the best snapshot - prefer one close to but before the start time\n  let baseSnapshot = null;\n  let baseSnapshotIndex = -1;\n\n  // First, look for snapshots within 30 seconds before the trim start\n  const threshold = 30000; // 30 seconds in milliseconds\n  for (const { snapshot, index } of fullSnapshots) {\n    if (\n      snapshot.timestamp <= startMs &&\n      snapshot.timestamp >= startMs - threshold\n    ) {\n      baseSnapshot = snapshot;\n      baseSnapshotIndex = index;\n    }\n  }\n\n  // If no snapshot within threshold, find the closest one before start\n  if (!baseSnapshot) {\n    for (const { snapshot, index } of fullSnapshots) {\n      if (snapshot.timestamp <= startMs) {\n        baseSnapshot = snapshot;\n        baseSnapshotIndex = index;\n      }\n    }\n  }\n\n  // If still no snapshot (trim starts before first snapshot), use the first one\n  if (!baseSnapshot) {\n    baseSnapshot = fullSnapshots[0].snapshot;\n    baseSnapshotIndex = fullSnapshots[0].index;\n  }\n\n  if (!baseSnapshot) {\n    throw new Error(\"No full snapshot found in recording\");\n  }\n\n  console.log(\n    `Using base snapshot at index ${baseSnapshotIndex}, timestamp ${baseSnapshot.timestamp}ms`\n  );\n  console.log(\n    `Time from base snapshot to trim start: ${\n      (startMs - baseSnapshot.timestamp) / 1000\n    } seconds`\n  );\n\n  // Build the new events array\n  const newEvents = [];\n\n  // IMPORTANT: We need to include the minimum set of events to reconstruct the DOM at startMs\n  // This means:\n  // 1. The base snapshot\n  // 2. All mutations from base snapshot to startMs (to build correct DOM state)\n  // 3. All events from startMs to endMs (the actual content we want)\n\n  // Add the base snapshot\n  newEvents.push({\n    ...baseSnapshot,\n    timestamp: baseSnapshot.timestamp,\n  });\n\n  // Add meta event if we have one\n  const metaEvent = events.find((e) => e.type === 4);\n  if (metaEvent) {\n    newEvents.push({\n      ...metaEvent,\n      timestamp: baseSnapshot.timestamp + 1,\n    });\n  }\n\n  // Count events in different ranges for debugging\n  let eventsBeforeTrim = 0;\n  let eventsInTrim = 0;\n\n  // Include necessary events to reconstruct DOM state at startMs\n  // and all events within the trim range\n  for (let i = baseSnapshotIndex + 1; i < events.length; i++) {\n    const event = events[i];\n\n    // Stop if we've passed the end time\n    if (event.timestamp > endMs) {\n      break;\n    }\n\n    // Skip full snapshots - we already have our base\n    if (event.type === 2) {\n      continue;\n    }\n\n    // For events before the trim start, only include mutations\n    // that are necessary for DOM reconstruction\n    if (event.timestamp < startMs) {\n      // Only include incremental snapshots (mutations)\n      if (event.type === 3 && event.data && event.data.source === 0) {\n        newEvents.push(event);\n        eventsBeforeTrim++;\n      }\n    } else {\n      // Include all events within the trim range\n      newEvents.push(event);\n      eventsInTrim++;\n    }\n  }\n\n  console.log(`Events included before trim start: ${eventsBeforeTrim}`);\n  console.log(`Events included within trim range: ${eventsInTrim}`);\n\n  // Sort by timestamp to ensure proper order\n  newEvents.sort((a, b) => a.timestamp - b.timestamp);\n\n  // If we need at least 2 events and only have 1, add a minimal event\n  if (newEvents.length === 1) {\n    console.log(\"Only one event found, adding minimal event\");\n    newEvents.push({\n      type: 3, // IncrementalSnapshot\n      data: {\n        source: 0, // Mutation\n        texts: [],\n        attributes: [],\n        removes: [],\n        adds: [],\n      },\n      timestamp: baseSnapshot.timestamp + 10,\n    });\n  }\n\n  // IMPORTANT: Shift timestamps so playback starts at the trim point\n  // This makes the recording appear to start at the selected time\n  const timeShift = startMs - baseSnapshot.timestamp;\n  const baseTime = newEvents[0].timestamp;\n\n  console.log(`Time shift: ${timeShift / 1000} seconds`);\n  console.log(`Adjusting timestamps to start playback at trim point...`);\n\n  // Adjust all timestamps\n  const shiftedEvents = newEvents.map((event, index) => {\n    // Calculate relative time from base\n    const relativeTime = event.timestamp - baseTime;\n\n    // For events before the trim start, compress them into the first 100ms\n    // This ensures DOM is built quickly without showing long buildup\n    if (\n      event.timestamp < startMs &&\n      event.type === 3 &&\n      event.data.source === 0\n    ) {\n      // Compress pre-trim mutations into first 100ms\n      const compressionRatio = Math.min(relativeTime / timeShift, 1);\n      return {\n        ...event,\n        timestamp: compressionRatio * 100,\n      };\n    } else {\n      // For events at or after trim start, maintain relative timing\n      const newTimestamp = event.timestamp - startMs + 100;\n      return {\n        ...event,\n        timestamp: newTimestamp,\n      };\n    }\n  });\n\n  console.log(`Original recording: ${events.length} events`);\n  console.log(`Trimmed recording: ${shiftedEvents.length} events`);\n  console.log(\n    `Original time range: ${newEvents[0].timestamp}ms to ${\n      newEvents[newEvents.length - 1].timestamp\n    }ms`\n  );\n  console.log(\n    `Shifted time range: ${shiftedEvents[0].timestamp}ms to ${\n      shiftedEvents[shiftedEvents.length - 1].timestamp\n    }ms`\n  );\n  console.log(`Requested trim range: ${startMs}ms to ${endMs}ms`);\n\n  // Validate we have at least 2 events\n  if (shiftedEvents.length < 2) {\n    throw new Error(\n      `Trimmed recording has only ${shiftedEvents.length} events, need at least 2`\n    );\n  }\n\n  return shiftedEvents;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}