{"ast":null,"code":"// RecordingCutter.js - Utility for cutting rrweb recordings into smaller clips\n\nimport { Replayer } from \"rrweb\";\nimport { snapshot } from \"rrweb-snapshot\";\n\n/**\n * Converts absolute timestamp to relative seconds\n * @param {Array} events - rrweb events array\n * @param {number} timestamp - Absolute timestamp\n * @returns {number} Relative seconds from start\n */\nexport function timestampToRelativeTime(events, timestamp) {\n  if (!events || events.length === 0) return 0;\n  const startTime = events[0].timestamp;\n  return (timestamp - startTime) / 1000;\n}\n\n/**\n * Formats seconds as MM:SS or HH:MM:SS\n * @param {number} seconds - Total seconds\n * @returns {string} Formatted time string\n */\nexport function formatTime(seconds) {\n  const hours = Math.floor(seconds / 3600);\n  const minutes = Math.floor(seconds % 3600 / 60);\n  const secs = Math.floor(seconds % 60);\n  if (hours > 0) {\n    return `${hours}:${minutes.toString().padStart(2, \"0\")}:${secs.toString().padStart(2, \"0\")}`;\n  }\n  return `${minutes}:${secs.toString().padStart(2, \"0\")}`;\n}\n\n/**\n * Parses time string (MM:SS, HH:MM:SS, or just seconds) to total seconds\n * @param {string} timeStr - Time string like \"1:30\", \"0:05\", \"90\", etc.\n * @returns {number} Total seconds\n */\nexport function parseTimeString(timeStr) {\n  if (!timeStr) return 0;\n\n  // If it's just a number, treat as seconds\n  if (/^\\d+$/.test(timeStr)) {\n    return parseInt(timeStr);\n  }\n\n  // Parse MM:SS or HH:MM:SS format\n  const parts = timeStr.split(\":\").map(Number);\n  if (parts.length === 2) {\n    // MM:SS\n    return parts[0] * 60 + parts[1];\n  } else if (parts.length === 3) {\n    // HH:MM:SS\n    return parts[0] * 3600 + parts[1] * 60 + parts[2];\n  }\n  return 0;\n}\n\n/**\n * Cuts an rrweb recording to show only events within a specific time range\n * @param {Array} events - Original rrweb events array\n * @param {number} centerTimeSeconds - Relative time in seconds from start of recording\n * @param {number} beforeSeconds - Seconds to include before the center time (default: 5)\n * @param {number} afterSeconds - Seconds to include after the center time (default: 5)\n * @returns {Array} New rrweb events array for the clipped recording\n */\nexport function cutRecording(events, centerTimeSeconds, beforeSeconds = 5, afterSeconds = 5) {\n  if (!events || !Array.isArray(events) || events.length === 0) {\n    throw new Error(\"Invalid events array provided\");\n  }\n\n  // Convert relative time to absolute timestamp\n  const startTime = events[0].timestamp;\n  const centerTimestamp = startTime + centerTimeSeconds * 1000;\n  const beforeMs = beforeSeconds * 1000;\n  const afterMs = afterSeconds * 1000;\n  const cutStartTime = centerTimestamp - beforeMs;\n  const cutEndTime = centerTimestamp + afterMs;\n  console.log(`Cutting recording around ${formatTime(centerTimeSeconds)} (${centerTimeSeconds}s)`);\n  console.log(`Time range: ${formatTime(centerTimeSeconds - beforeSeconds)} to ${formatTime(centerTimeSeconds + afterSeconds)}`);\n\n  // Find the full snapshot that's closest to our cut time (before or after)\n  let fullSnapshot = null;\n  let bestDistance = Infinity;\n  for (const event of events) {\n    if (event.type === 2) {\n      const distance = Math.abs(event.timestamp - cutStartTime);\n      if (distance < bestDistance) {\n        fullSnapshot = event;\n        bestDistance = distance;\n      }\n    }\n  }\n  if (!fullSnapshot) {\n    throw new Error(\"No full snapshot found in recording\");\n  }\n  console.log(`Using full snapshot at ${fullSnapshot.timestamp}, distance from cut: ${bestDistance}ms`);\n\n  // Take a conservative approach: include ALL events\n  // from the closest full snapshot through our entire clip range\n  const snapshotTime = fullSnapshot.timestamp;\n  const rangeStart = Math.min(snapshotTime, cutStartTime);\n  const rangeEnd = cutEndTime;\n\n  // Get all events in the complete range we need\n  const neededEvents = events.filter(event => {\n    return event.timestamp >= rangeStart && event.timestamp <= rangeEnd;\n  });\n\n  // Create the new events array, ALWAYS starting with the full snapshot\n  const newEvents = [];\n\n  // Always add the full snapshot first\n  newEvents.push({\n    ...fullSnapshot,\n    timestamp: fullSnapshot.timestamp\n  });\n\n  // Add all other needed events (excluding the original full snapshot to avoid duplication)\n  for (const event of neededEvents) {\n    if (event.timestamp !== fullSnapshot.timestamp || event.type !== 2) {\n      newEvents.push({\n        ...event,\n        timestamp: event.timestamp\n      });\n    }\n  }\n\n  // Ensure we have at least 2 events total\n  if (newEvents.length < 2) {\n    const lastTimestamp = newEvents[newEvents.length - 1].timestamp;\n    newEvents.push({\n      type: 4,\n      // Meta event\n      data: {\n        href: window.location.href\n      },\n      timestamp: lastTimestamp + 100\n    });\n  }\n\n  // Sort by timestamp to ensure proper order\n  newEvents.sort((a, b) => a.timestamp - b.timestamp);\n  console.log(`Original recording: ${events.length} events`);\n  console.log(`Clipped recording: ${newEvents.length} events`);\n  console.log(`Time span: ${beforeSeconds + afterSeconds} seconds`);\n  return newEvents;\n}\n\n/**\n * Finds events containing specific text or attributes\n * @param {Array} events - rrweb events array\n * @param {string} searchTerm - Text to search for\n * @returns {Array} Array of events containing the search term\n */\nexport function findEventsByContent(events, searchTerm) {\n  const matchingEvents = [];\n  for (const event of events) {\n    const eventStr = JSON.stringify(event).toLowerCase();\n    if (eventStr.includes(searchTerm.toLowerCase())) {\n      matchingEvents.push(event);\n    }\n  }\n  return matchingEvents;\n}\n\n/**\n * Analyzes a recording and provides statistics\n * @param {Array} events - rrweb events array\n * @returns {Object} Recording statistics\n */\nexport function analyzeRecording(events) {\n  if (!events || !Array.isArray(events) || events.length === 0) {\n    return null;\n  }\n  const firstTimestamp = events[0].timestamp;\n  const lastTimestamp = events[events.length - 1].timestamp;\n  const duration = (lastTimestamp - firstTimestamp) / 1000; // in seconds\n\n  const eventTypeCounts = {};\n  for (const event of events) {\n    eventTypeCounts[event.type] = (eventTypeCounts[event.type] || 0) + 1;\n  }\n  return {\n    totalEvents: events.length,\n    duration: duration,\n    startTime: firstTimestamp,\n    endTime: lastTimestamp,\n    eventTypeCounts: eventTypeCounts,\n    eventTypes: {\n      1: \"DomContentLoaded\",\n      2: \"FullSnapshot\",\n      3: \"IncrementalSnapshot\",\n      4: \"Meta\",\n      5: \"Custom\",\n      6: \"Plugin\"\n    }\n  };\n}\n\n/**\n * Helper function to ensure pause completes\n * @param {Object} replayer - The rrweb replayer instance\n * @param {number} relativeTime - Target relative time from start\n * @returns {Promise<void>}\n */\nconst pauseAndWait = (replayer, relativeTime) => {\n  return new Promise((resolve, reject) => {\n    try {\n      // Pause the replayer\n      replayer.pause();\n\n      // Wait for DOM to be fully reconstructed\n      setTimeout(() => {\n        const currentTime = replayer.getCurrentTime();\n        console.log(`Paused at: ${currentTime}ms, Target relative time: ${relativeTime}ms`);\n        resolve();\n      }, 300); // Give DOM more time to stabilize\n    } catch (error) {\n      reject(error);\n    }\n  });\n};\n\n/**\n * Creates a true synthetic snapshot by replaying to a specific point and capturing DOM state\n * @param {Array} events - Original rrweb events array\n * @param {number} targetTimestamp - The timestamp to capture DOM state at\n * @returns {Promise<Object>} Synthetic full snapshot at the target timestamp\n */\nasync function createTrueSyntheticSnapshot(events, targetTimestamp) {\n  return new Promise(async (resolve, reject) => {\n    let container = null;\n    let replayer = null;\n    try {\n      var _events$find;\n      // Create a hidden container for replay\n      container = document.createElement(\"div\");\n      container.style.position = \"fixed\";\n      container.style.top = \"-9999px\";\n      container.style.left = \"-9999px\";\n      container.style.width = \"1920px\";\n      container.style.height = \"1080px\";\n      container.style.overflow = \"hidden\";\n      container.style.visibility = \"hidden\";\n      document.body.appendChild(container);\n\n      // Get the start time from events\n      const startTime = events[0].timestamp;\n      const relativeTarget = targetTimestamp - startTime;\n      console.log(`Creating replayer for synthetic snapshot at ${targetTimestamp}ms (relative: ${relativeTarget}ms)`);\n\n      // Create replayer with synchronous rendering\n      replayer = new Replayer(events, {\n        root: container,\n        skipInactive: false,\n        showWarning: false,\n        showDebug: false,\n        blockClass: \"rr-block\",\n        maskTextClass: \"rr-mask\",\n        speed: 1,\n        mouseTail: false,\n        triggerFocus: false,\n        UNSAFE_replayCanvas: false,\n        useVirtualDom: false,\n        plugins: []\n      });\n\n      // Wait for replayer to initialize\n      await new Promise(resolve => setTimeout(resolve, 100));\n\n      // Get replayer metadata to check if it's ready\n      const replayerMeta = replayer.getMetaData();\n      console.log(\"Replayer metadata:\", replayerMeta);\n\n      // Play to target time\n      replayer.play(relativeTarget);\n\n      // Wait for playback to reach target\n      await new Promise((resolve, reject) => {\n        let attempts = 0;\n        const maxAttempts = 1000; // 10 seconds max\n\n        const checkInterval = setInterval(() => {\n          attempts++;\n          const currentTime = replayer.getCurrentTime();\n          if (currentTime >= relativeTarget - 10) {\n            clearInterval(checkInterval);\n            console.log(`Reached target time after ${attempts * 10}ms`);\n            resolve();\n          } else if (attempts >= maxAttempts) {\n            clearInterval(checkInterval);\n            reject(new Error(`Timeout waiting for playback to reach target. Current: ${currentTime}, Target: ${relativeTarget}`));\n          }\n        }, 10);\n      });\n\n      // Pause and wait for DOM to stabilize\n      await pauseAndWait(replayer, relativeTarget);\n\n      // Get the iframe\n      const iframe = container.querySelector(\"iframe\");\n      if (!iframe) {\n        console.error(\"No iframe found in container\");\n        console.error(\"Container innerHTML:\", container.innerHTML);\n        throw new Error(\"Could not find replay iframe\");\n      }\n      if (!iframe.contentDocument) {\n        console.error(\"iframe.contentDocument is null\");\n        console.error(\"iframe src:\", iframe.src);\n        throw new Error(\"Could not access iframe content document\");\n      }\n      console.log(\"Taking snapshot of iframe content...\");\n\n      // Take the snapshot\n      const domSnapshot = snapshot(iframe.contentDocument, {\n        blockClass: \"rr-block\",\n        maskTextClass: \"rr-mask\",\n        ignoreClass: \"rr-ignore\",\n        inlineStylesheet: true,\n        maskAllInputs: false,\n        preserveWhiteSpace: true\n      });\n      if (!domSnapshot) {\n        throw new Error(\"Snapshot returned null\");\n      }\n\n      // Get metadata\n      const meta = replayer.getMetaData() || {};\n      const tabId = (_events$find = events.find(e => e.tabId)) === null || _events$find === void 0 ? void 0 : _events$find.tabId;\n\n      // Create the synthetic full snapshot event\n      const syntheticSnapshot = {\n        type: 2,\n        // FullSnapshot\n        data: {\n          node: domSnapshot,\n          initialOffset: {\n            left: 0,\n            top: 0\n          }\n        },\n        timestamp: targetTimestamp\n      };\n\n      // Add tabId if present\n      if (tabId !== undefined) {\n        syntheticSnapshot.tabId = tabId;\n      }\n\n      // Clean up\n      replayer.destroy();\n      document.body.removeChild(container);\n      console.log(\"Synthetic snapshot created successfully\");\n      resolve(syntheticSnapshot);\n    } catch (error) {\n      console.error(\"Error creating synthetic snapshot:\", error);\n\n      // Clean up on error\n      if (replayer) {\n        try {\n          replayer.destroy();\n        } catch (e) {\n          console.error(\"Error destroying replayer:\", e);\n        }\n      }\n      if (container && container.parentNode) {\n        document.body.removeChild(container);\n      }\n      reject(error);\n    }\n  });\n}\n\n/**\n * Trims a recording to keep only events within a specific time range\n * @param {Array} events - Original rrweb events array\n * @param {number} startMs - Start time in milliseconds (absolute timestamp)\n * @param {number} endMs - End time in milliseconds (absolute timestamp)\n * @returns {Array} New rrweb events array for the trimmed recording\n */\nexport async function trimRecording(events, startMs, endMs) {\n  if (!events || !Array.isArray(events) || events.length === 0) {\n    throw new Error(\"Invalid events array provided\");\n  }\n  console.log(`Trimming recording from ${startMs}ms to ${endMs}ms`);\n  console.log(`Duration to trim: ${(endMs - startMs) / 1000} seconds`);\n\n  // Validate time range\n  const recordingStart = events[0].timestamp;\n  const recordingEnd = events[events.length - 1].timestamp;\n  console.log(`Recording spans from ${recordingStart} to ${recordingEnd}`);\n  console.log(`Recording total duration: ${(recordingEnd - recordingStart) / 1000} seconds`);\n  if (startMs < recordingStart) {\n    console.warn(`Start time ${startMs}ms is before recording start ${recordingStart}ms, adjusting`);\n    startMs = recordingStart;\n  }\n  if (endMs > recordingEnd) {\n    console.warn(`End time ${endMs}ms is after recording end ${recordingEnd}ms, adjusting`);\n    endMs = recordingEnd;\n  }\n  if (startMs >= endMs) {\n    console.error(`Invalid time range: startMs=${startMs}, endMs=${endMs}`);\n    throw new Error(`Invalid time range: start time (${startMs}ms) must be before end time (${endMs}ms)`);\n  }\n  try {\n    var _originalMeta$data, _originalMeta$data2, _originalMeta$data3;\n    // Create a true synthetic snapshot at the exact trim start point\n    console.log(`Creating synthetic snapshot at trim start point (${startMs}ms)...`);\n\n    // First, try the simple approach - check if we have a snapshot close enough\n    const snapshots = events.filter(e => e.type === 2);\n    const closeSnapshot = snapshots.find(s => Math.abs(s.timestamp - startMs) < 1000 // Within 1 second\n    );\n    let syntheticSnapshot;\n    if (closeSnapshot && closeSnapshot.timestamp === startMs) {\n      // Perfect match - use it directly\n      console.log(`Found exact snapshot at trim point`);\n      syntheticSnapshot = closeSnapshot;\n    } else {\n      // Need to create synthetic snapshot\n      syntheticSnapshot = await createTrueSyntheticSnapshot(events, startMs);\n      console.log(`Synthetic snapshot created successfully`);\n    }\n\n    // Build the new events array starting at 0\n    const newEvents = [];\n\n    // Get original meta event for viewport info\n    const originalMeta = events.find(e => e.type === 4);\n\n    // Create meta event at timestamp 0\n    const metaEvent = {\n      type: 4,\n      // Meta\n      data: {\n        href: (originalMeta === null || originalMeta === void 0 ? void 0 : (_originalMeta$data = originalMeta.data) === null || _originalMeta$data === void 0 ? void 0 : _originalMeta$data.href) || window.location.href,\n        width: (originalMeta === null || originalMeta === void 0 ? void 0 : (_originalMeta$data2 = originalMeta.data) === null || _originalMeta$data2 === void 0 ? void 0 : _originalMeta$data2.width) || 1920,\n        height: (originalMeta === null || originalMeta === void 0 ? void 0 : (_originalMeta$data3 = originalMeta.data) === null || _originalMeta$data3 === void 0 ? void 0 : _originalMeta$data3.height) || 1080\n      },\n      timestamp: 0\n    };\n\n    // Add tabId if present\n    if (syntheticSnapshot.tabId !== undefined) {\n      metaEvent.tabId = syntheticSnapshot.tabId;\n    }\n    newEvents.push(metaEvent);\n\n    // Add synthetic snapshot at timestamp 1\n    const adjustedSnapshot = {\n      ...syntheticSnapshot,\n      timestamp: 1\n    };\n    newEvents.push(adjustedSnapshot);\n\n    // Include only events within the trim range, adjusting timestamps\n    const eventsInRange = events.filter(event => {\n      return event.timestamp > startMs && event.timestamp <= endMs;\n    });\n    console.log(`Found ${eventsInRange.length} events within trim range`);\n\n    // Add all events in range with adjusted timestamps\n    for (const event of eventsInRange) {\n      const adjustedEvent = {\n        ...event,\n        timestamp: event.timestamp - startMs + 2 // Start after meta and snapshot\n      };\n      newEvents.push(adjustedEvent);\n    }\n\n    // Sort by timestamp (should already be in order)\n    newEvents.sort((a, b) => a.timestamp - b.timestamp);\n    console.log(`Original recording: ${events.length} events`);\n    console.log(`Trimmed recording: ${newEvents.length} events`);\n    console.log(`Trimmed duration: ${(endMs - startMs) / 1000} seconds`);\n    return newEvents;\n  } catch (error) {\n    console.error(\"Failed to create synthetic snapshot:\", error);\n\n    // Fallback to the old method if synthetic snapshot fails\n    console.log(\"Falling back to traditional trim method...\");\n    return trimRecordingFallback(events, startMs, endMs);\n  }\n}\n\n// Keep the old implementation as a fallback\nfunction trimRecordingFallback(events, startMs, endMs) {\n  // Find ALL full snapshots and choose the best one\n  const fullSnapshots = [];\n  for (let i = 0; i < events.length; i++) {\n    if (events[i].type === 2) {\n      fullSnapshots.push({\n        snapshot: events[i],\n        index: i\n      });\n    }\n  }\n  if (fullSnapshots.length === 0) {\n    throw new Error(\"No full snapshot found in recording\");\n  }\n\n  // Find the best snapshot - prefer one close to but before the start time\n  let baseSnapshot = null;\n  let baseSnapshotIndex = -1;\n\n  // First, look for snapshots within 30 seconds before the trim start\n  const threshold = 30000; // 30 seconds in milliseconds\n  for (const {\n    snapshot,\n    index\n  } of fullSnapshots) {\n    if (snapshot.timestamp <= startMs && snapshot.timestamp >= startMs - threshold) {\n      baseSnapshot = snapshot;\n      baseSnapshotIndex = index;\n    }\n  }\n\n  // If no snapshot within threshold, find the closest one before start\n  if (!baseSnapshot) {\n    for (const {\n      snapshot,\n      index\n    } of fullSnapshots) {\n      if (snapshot.timestamp <= startMs) {\n        baseSnapshot = snapshot;\n        baseSnapshotIndex = index;\n      }\n    }\n  }\n\n  // If still no snapshot (trim starts before first snapshot), use the first one\n  if (!baseSnapshot) {\n    baseSnapshot = fullSnapshots[0].snapshot;\n    baseSnapshotIndex = fullSnapshots[0].index;\n  }\n  if (!baseSnapshot) {\n    throw new Error(\"No full snapshot found in recording\");\n  }\n  console.log(`Using base snapshot at index ${baseSnapshotIndex}, timestamp ${baseSnapshot.timestamp}ms`);\n  console.log(`Time from base snapshot to trim start: ${(startMs - baseSnapshot.timestamp) / 1000} seconds`);\n\n  // Build the new events array\n  const newEvents = [];\n\n  // Add the base snapshot\n  newEvents.push({\n    ...baseSnapshot,\n    timestamp: baseSnapshot.timestamp\n  });\n\n  // Add meta event if we have one\n  const metaEvent = events.find(e => e.type === 4);\n  if (metaEvent) {\n    newEvents.push({\n      ...metaEvent,\n      timestamp: baseSnapshot.timestamp + 1\n    });\n  }\n\n  // Count events in different ranges for debugging\n  let eventsBeforeTrim = 0;\n  let eventsInTrim = 0;\n\n  // Include necessary events to reconstruct DOM state at startMs\n  // and all events within the trim range\n  for (let i = baseSnapshotIndex + 1; i < events.length; i++) {\n    const event = events[i];\n\n    // Stop if we've passed the end time\n    if (event.timestamp > endMs) {\n      break;\n    }\n\n    // Skip full snapshots - we already have our base\n    if (event.type === 2) {\n      continue;\n    }\n\n    // For events before the trim start, only include mutations\n    // that are necessary for DOM reconstruction\n    if (event.timestamp < startMs) {\n      // Only include incremental snapshots (mutations)\n      if (event.type === 3 && event.data && event.data.source === 0) {\n        newEvents.push(event);\n        eventsBeforeTrim++;\n      }\n    } else {\n      // Include all events within the trim range\n      newEvents.push(event);\n      eventsInTrim++;\n    }\n  }\n  console.log(`Events included before trim start: ${eventsBeforeTrim}`);\n  console.log(`Events included within trim range: ${eventsInTrim}`);\n\n  // Sort by timestamp to ensure proper order\n  newEvents.sort((a, b) => a.timestamp - b.timestamp);\n\n  // If we need at least 2 events and only have 1, add a minimal event\n  if (newEvents.length === 1) {\n    console.log(\"Only one event found, adding minimal event\");\n    newEvents.push({\n      type: 3,\n      // IncrementalSnapshot\n      data: {\n        source: 0,\n        // Mutation\n        texts: [],\n        attributes: [],\n        removes: [],\n        adds: []\n      },\n      timestamp: baseSnapshot.timestamp + 10\n    });\n  }\n\n  // Shift timestamps so playback starts at the trim point\n  const timeShift = startMs - baseSnapshot.timestamp;\n  const baseTime = newEvents[0].timestamp;\n  console.log(`Time shift: ${timeShift / 1000} seconds`);\n  console.log(`Adjusting timestamps to start playback at trim point...`);\n\n  // Adjust all timestamps\n  const shiftedEvents = newEvents.map((event, index) => {\n    // Calculate relative time from base\n    const relativeTime = event.timestamp - baseTime;\n\n    // For events before the trim start, compress them into the first 100ms\n    if (event.timestamp < startMs && event.type === 3 && event.data.source === 0) {\n      // Compress pre-trim mutations into first 100ms\n      const compressionRatio = Math.min(relativeTime / timeShift, 1);\n      return {\n        ...event,\n        timestamp: compressionRatio * 100\n      };\n    } else {\n      // For events at or after trim start, maintain relative timing\n      const newTimestamp = event.timestamp - startMs + 100;\n      return {\n        ...event,\n        timestamp: newTimestamp\n      };\n    }\n  });\n  console.log(`Original recording: ${events.length} events`);\n  console.log(`Trimmed recording: ${shiftedEvents.length} events`);\n\n  // Validate we have at least 2 events\n  if (shiftedEvents.length < 2) {\n    throw new Error(`Trimmed recording has only ${shiftedEvents.length} events, need at least 2`);\n  }\n  return shiftedEvents;\n}","map":{"version":3,"names":["Replayer","snapshot","timestampToRelativeTime","events","timestamp","length","startTime","formatTime","seconds","hours","Math","floor","minutes","secs","toString","padStart","parseTimeString","timeStr","test","parseInt","parts","split","map","Number","cutRecording","centerTimeSeconds","beforeSeconds","afterSeconds","Array","isArray","Error","centerTimestamp","beforeMs","afterMs","cutStartTime","cutEndTime","console","log","fullSnapshot","bestDistance","Infinity","event","type","distance","abs","snapshotTime","rangeStart","min","rangeEnd","neededEvents","filter","newEvents","push","lastTimestamp","data","href","window","location","sort","a","b","findEventsByContent","searchTerm","matchingEvents","eventStr","JSON","stringify","toLowerCase","includes","analyzeRecording","firstTimestamp","duration","eventTypeCounts","totalEvents","endTime","eventTypes","pauseAndWait","replayer","relativeTime","Promise","resolve","reject","pause","setTimeout","currentTime","getCurrentTime","error","createTrueSyntheticSnapshot","targetTimestamp","container","_events$find","document","createElement","style","position","top","left","width","height","overflow","visibility","body","appendChild","relativeTarget","root","skipInactive","showWarning","showDebug","blockClass","maskTextClass","speed","mouseTail","triggerFocus","UNSAFE_replayCanvas","useVirtualDom","plugins","replayerMeta","getMetaData","play","attempts","maxAttempts","checkInterval","setInterval","clearInterval","iframe","querySelector","innerHTML","contentDocument","src","domSnapshot","ignoreClass","inlineStylesheet","maskAllInputs","preserveWhiteSpace","meta","tabId","find","e","syntheticSnapshot","node","initialOffset","undefined","destroy","removeChild","parentNode","trimRecording","startMs","endMs","recordingStart","recordingEnd","warn","_originalMeta$data","_originalMeta$data2","_originalMeta$data3","snapshots","closeSnapshot","s","originalMeta","metaEvent","adjustedSnapshot","eventsInRange","adjustedEvent","trimRecordingFallback","fullSnapshots","i","index","baseSnapshot","baseSnapshotIndex","threshold","eventsBeforeTrim","eventsInTrim","source","texts","attributes","removes","adds","timeShift","baseTime","shiftedEvents","compressionRatio","newTimestamp"],"sources":["/Users/ogonen/rrweb/src/RecordingCutter.js"],"sourcesContent":["// RecordingCutter.js - Utility for cutting rrweb recordings into smaller clips\n\nimport { Replayer } from \"rrweb\";\nimport { snapshot } from \"rrweb-snapshot\";\n\n/**\n * Converts absolute timestamp to relative seconds\n * @param {Array} events - rrweb events array\n * @param {number} timestamp - Absolute timestamp\n * @returns {number} Relative seconds from start\n */\nexport function timestampToRelativeTime(events, timestamp) {\n  if (!events || events.length === 0) return 0;\n  const startTime = events[0].timestamp;\n  return (timestamp - startTime) / 1000;\n}\n\n/**\n * Formats seconds as MM:SS or HH:MM:SS\n * @param {number} seconds - Total seconds\n * @returns {string} Formatted time string\n */\nexport function formatTime(seconds) {\n  const hours = Math.floor(seconds / 3600);\n  const minutes = Math.floor((seconds % 3600) / 60);\n  const secs = Math.floor(seconds % 60);\n\n  if (hours > 0) {\n    return `${hours}:${minutes.toString().padStart(2, \"0\")}:${secs\n      .toString()\n      .padStart(2, \"0\")}`;\n  }\n  return `${minutes}:${secs.toString().padStart(2, \"0\")}`;\n}\n\n/**\n * Parses time string (MM:SS, HH:MM:SS, or just seconds) to total seconds\n * @param {string} timeStr - Time string like \"1:30\", \"0:05\", \"90\", etc.\n * @returns {number} Total seconds\n */\nexport function parseTimeString(timeStr) {\n  if (!timeStr) return 0;\n\n  // If it's just a number, treat as seconds\n  if (/^\\d+$/.test(timeStr)) {\n    return parseInt(timeStr);\n  }\n\n  // Parse MM:SS or HH:MM:SS format\n  const parts = timeStr.split(\":\").map(Number);\n  if (parts.length === 2) {\n    // MM:SS\n    return parts[0] * 60 + parts[1];\n  } else if (parts.length === 3) {\n    // HH:MM:SS\n    return parts[0] * 3600 + parts[1] * 60 + parts[2];\n  }\n\n  return 0;\n}\n\n/**\n * Cuts an rrweb recording to show only events within a specific time range\n * @param {Array} events - Original rrweb events array\n * @param {number} centerTimeSeconds - Relative time in seconds from start of recording\n * @param {number} beforeSeconds - Seconds to include before the center time (default: 5)\n * @param {number} afterSeconds - Seconds to include after the center time (default: 5)\n * @returns {Array} New rrweb events array for the clipped recording\n */\nexport function cutRecording(\n  events,\n  centerTimeSeconds,\n  beforeSeconds = 5,\n  afterSeconds = 5\n) {\n  if (!events || !Array.isArray(events) || events.length === 0) {\n    throw new Error(\"Invalid events array provided\");\n  }\n\n  // Convert relative time to absolute timestamp\n  const startTime = events[0].timestamp;\n  const centerTimestamp = startTime + centerTimeSeconds * 1000;\n\n  const beforeMs = beforeSeconds * 1000;\n  const afterMs = afterSeconds * 1000;\n  const cutStartTime = centerTimestamp - beforeMs;\n  const cutEndTime = centerTimestamp + afterMs;\n\n  console.log(\n    `Cutting recording around ${formatTime(\n      centerTimeSeconds\n    )} (${centerTimeSeconds}s)`\n  );\n  console.log(\n    `Time range: ${formatTime(\n      centerTimeSeconds - beforeSeconds\n    )} to ${formatTime(centerTimeSeconds + afterSeconds)}`\n  );\n\n  // Find the full snapshot that's closest to our cut time (before or after)\n  let fullSnapshot = null;\n  let bestDistance = Infinity;\n\n  for (const event of events) {\n    if (event.type === 2) {\n      const distance = Math.abs(event.timestamp - cutStartTime);\n      if (distance < bestDistance) {\n        fullSnapshot = event;\n        bestDistance = distance;\n      }\n    }\n  }\n\n  if (!fullSnapshot) {\n    throw new Error(\"No full snapshot found in recording\");\n  }\n\n  console.log(\n    `Using full snapshot at ${fullSnapshot.timestamp}, distance from cut: ${bestDistance}ms`\n  );\n\n  // Take a conservative approach: include ALL events\n  // from the closest full snapshot through our entire clip range\n  const snapshotTime = fullSnapshot.timestamp;\n  const rangeStart = Math.min(snapshotTime, cutStartTime);\n  const rangeEnd = cutEndTime;\n\n  // Get all events in the complete range we need\n  const neededEvents = events.filter((event) => {\n    return event.timestamp >= rangeStart && event.timestamp <= rangeEnd;\n  });\n\n  // Create the new events array, ALWAYS starting with the full snapshot\n  const newEvents = [];\n\n  // Always add the full snapshot first\n  newEvents.push({\n    ...fullSnapshot,\n    timestamp: fullSnapshot.timestamp,\n  });\n\n  // Add all other needed events (excluding the original full snapshot to avoid duplication)\n  for (const event of neededEvents) {\n    if (event.timestamp !== fullSnapshot.timestamp || event.type !== 2) {\n      newEvents.push({\n        ...event,\n        timestamp: event.timestamp,\n      });\n    }\n  }\n\n  // Ensure we have at least 2 events total\n  if (newEvents.length < 2) {\n    const lastTimestamp = newEvents[newEvents.length - 1].timestamp;\n    newEvents.push({\n      type: 4, // Meta event\n      data: { href: window.location.href },\n      timestamp: lastTimestamp + 100,\n    });\n  }\n\n  // Sort by timestamp to ensure proper order\n  newEvents.sort((a, b) => a.timestamp - b.timestamp);\n\n  console.log(`Original recording: ${events.length} events`);\n  console.log(`Clipped recording: ${newEvents.length} events`);\n  console.log(`Time span: ${beforeSeconds + afterSeconds} seconds`);\n\n  return newEvents;\n}\n\n/**\n * Finds events containing specific text or attributes\n * @param {Array} events - rrweb events array\n * @param {string} searchTerm - Text to search for\n * @returns {Array} Array of events containing the search term\n */\nexport function findEventsByContent(events, searchTerm) {\n  const matchingEvents = [];\n\n  for (const event of events) {\n    const eventStr = JSON.stringify(event).toLowerCase();\n    if (eventStr.includes(searchTerm.toLowerCase())) {\n      matchingEvents.push(event);\n    }\n  }\n\n  return matchingEvents;\n}\n\n/**\n * Analyzes a recording and provides statistics\n * @param {Array} events - rrweb events array\n * @returns {Object} Recording statistics\n */\nexport function analyzeRecording(events) {\n  if (!events || !Array.isArray(events) || events.length === 0) {\n    return null;\n  }\n\n  const firstTimestamp = events[0].timestamp;\n  const lastTimestamp = events[events.length - 1].timestamp;\n  const duration = (lastTimestamp - firstTimestamp) / 1000; // in seconds\n\n  const eventTypeCounts = {};\n  for (const event of events) {\n    eventTypeCounts[event.type] = (eventTypeCounts[event.type] || 0) + 1;\n  }\n\n  return {\n    totalEvents: events.length,\n    duration: duration,\n    startTime: firstTimestamp,\n    endTime: lastTimestamp,\n    eventTypeCounts: eventTypeCounts,\n    eventTypes: {\n      1: \"DomContentLoaded\",\n      2: \"FullSnapshot\",\n      3: \"IncrementalSnapshot\",\n      4: \"Meta\",\n      5: \"Custom\",\n      6: \"Plugin\",\n    },\n  };\n}\n\n/**\n * Helper function to ensure pause completes\n * @param {Object} replayer - The rrweb replayer instance\n * @param {number} relativeTime - Target relative time from start\n * @returns {Promise<void>}\n */\nconst pauseAndWait = (replayer, relativeTime) => {\n  return new Promise((resolve, reject) => {\n    try {\n      // Pause the replayer\n      replayer.pause();\n\n      // Wait for DOM to be fully reconstructed\n      setTimeout(() => {\n        const currentTime = replayer.getCurrentTime();\n        console.log(\n          `Paused at: ${currentTime}ms, Target relative time: ${relativeTime}ms`\n        );\n        resolve();\n      }, 300); // Give DOM more time to stabilize\n    } catch (error) {\n      reject(error);\n    }\n  });\n};\n\n/**\n * Creates a true synthetic snapshot by replaying to a specific point and capturing DOM state\n * @param {Array} events - Original rrweb events array\n * @param {number} targetTimestamp - The timestamp to capture DOM state at\n * @returns {Promise<Object>} Synthetic full snapshot at the target timestamp\n */\nasync function createTrueSyntheticSnapshot(events, targetTimestamp) {\n  return new Promise(async (resolve, reject) => {\n    let container = null;\n    let replayer = null;\n\n    try {\n      // Create a hidden container for replay\n      container = document.createElement(\"div\");\n      container.style.position = \"fixed\";\n      container.style.top = \"-9999px\";\n      container.style.left = \"-9999px\";\n      container.style.width = \"1920px\";\n      container.style.height = \"1080px\";\n      container.style.overflow = \"hidden\";\n      container.style.visibility = \"hidden\";\n      document.body.appendChild(container);\n\n      // Get the start time from events\n      const startTime = events[0].timestamp;\n      const relativeTarget = targetTimestamp - startTime;\n\n      console.log(\n        `Creating replayer for synthetic snapshot at ${targetTimestamp}ms (relative: ${relativeTarget}ms)`\n      );\n\n      // Create replayer with synchronous rendering\n      replayer = new Replayer(events, {\n        root: container,\n        skipInactive: false,\n        showWarning: false,\n        showDebug: false,\n        blockClass: \"rr-block\",\n        maskTextClass: \"rr-mask\",\n        speed: 1,\n        mouseTail: false,\n        triggerFocus: false,\n        UNSAFE_replayCanvas: false,\n        useVirtualDom: false,\n        plugins: [],\n      });\n\n      // Wait for replayer to initialize\n      await new Promise((resolve) => setTimeout(resolve, 100));\n\n      // Get replayer metadata to check if it's ready\n      const replayerMeta = replayer.getMetaData();\n      console.log(\"Replayer metadata:\", replayerMeta);\n\n      // Play to target time\n      replayer.play(relativeTarget);\n\n      // Wait for playback to reach target\n      await new Promise((resolve, reject) => {\n        let attempts = 0;\n        const maxAttempts = 1000; // 10 seconds max\n\n        const checkInterval = setInterval(() => {\n          attempts++;\n          const currentTime = replayer.getCurrentTime();\n\n          if (currentTime >= relativeTarget - 10) {\n            clearInterval(checkInterval);\n            console.log(`Reached target time after ${attempts * 10}ms`);\n            resolve();\n          } else if (attempts >= maxAttempts) {\n            clearInterval(checkInterval);\n            reject(\n              new Error(\n                `Timeout waiting for playback to reach target. Current: ${currentTime}, Target: ${relativeTarget}`\n              )\n            );\n          }\n        }, 10);\n      });\n\n      // Pause and wait for DOM to stabilize\n      await pauseAndWait(replayer, relativeTarget);\n\n      // Get the iframe\n      const iframe = container.querySelector(\"iframe\");\n      if (!iframe) {\n        console.error(\"No iframe found in container\");\n        console.error(\"Container innerHTML:\", container.innerHTML);\n        throw new Error(\"Could not find replay iframe\");\n      }\n\n      if (!iframe.contentDocument) {\n        console.error(\"iframe.contentDocument is null\");\n        console.error(\"iframe src:\", iframe.src);\n        throw new Error(\"Could not access iframe content document\");\n      }\n\n      console.log(\"Taking snapshot of iframe content...\");\n\n      // Take the snapshot\n      const domSnapshot = snapshot(iframe.contentDocument, {\n        blockClass: \"rr-block\",\n        maskTextClass: \"rr-mask\",\n        ignoreClass: \"rr-ignore\",\n        inlineStylesheet: true,\n        maskAllInputs: false,\n        preserveWhiteSpace: true,\n      });\n\n      if (!domSnapshot) {\n        throw new Error(\"Snapshot returned null\");\n      }\n\n      // Get metadata\n      const meta = replayer.getMetaData() || {};\n      const tabId = events.find((e) => e.tabId)?.tabId;\n\n      // Create the synthetic full snapshot event\n      const syntheticSnapshot = {\n        type: 2, // FullSnapshot\n        data: {\n          node: domSnapshot,\n          initialOffset: {\n            left: 0,\n            top: 0,\n          },\n        },\n        timestamp: targetTimestamp,\n      };\n\n      // Add tabId if present\n      if (tabId !== undefined) {\n        syntheticSnapshot.tabId = tabId;\n      }\n\n      // Clean up\n      replayer.destroy();\n      document.body.removeChild(container);\n\n      console.log(\"Synthetic snapshot created successfully\");\n      resolve(syntheticSnapshot);\n    } catch (error) {\n      console.error(\"Error creating synthetic snapshot:\", error);\n\n      // Clean up on error\n      if (replayer) {\n        try {\n          replayer.destroy();\n        } catch (e) {\n          console.error(\"Error destroying replayer:\", e);\n        }\n      }\n      if (container && container.parentNode) {\n        document.body.removeChild(container);\n      }\n\n      reject(error);\n    }\n  });\n}\n\n/**\n * Trims a recording to keep only events within a specific time range\n * @param {Array} events - Original rrweb events array\n * @param {number} startMs - Start time in milliseconds (absolute timestamp)\n * @param {number} endMs - End time in milliseconds (absolute timestamp)\n * @returns {Array} New rrweb events array for the trimmed recording\n */\nexport async function trimRecording(events, startMs, endMs) {\n  if (!events || !Array.isArray(events) || events.length === 0) {\n    throw new Error(\"Invalid events array provided\");\n  }\n\n  console.log(`Trimming recording from ${startMs}ms to ${endMs}ms`);\n  console.log(`Duration to trim: ${(endMs - startMs) / 1000} seconds`);\n\n  // Validate time range\n  const recordingStart = events[0].timestamp;\n  const recordingEnd = events[events.length - 1].timestamp;\n\n  console.log(`Recording spans from ${recordingStart} to ${recordingEnd}`);\n  console.log(\n    `Recording total duration: ${\n      (recordingEnd - recordingStart) / 1000\n    } seconds`\n  );\n\n  if (startMs < recordingStart) {\n    console.warn(\n      `Start time ${startMs}ms is before recording start ${recordingStart}ms, adjusting`\n    );\n    startMs = recordingStart;\n  }\n\n  if (endMs > recordingEnd) {\n    console.warn(\n      `End time ${endMs}ms is after recording end ${recordingEnd}ms, adjusting`\n    );\n    endMs = recordingEnd;\n  }\n\n  if (startMs >= endMs) {\n    console.error(`Invalid time range: startMs=${startMs}, endMs=${endMs}`);\n    throw new Error(\n      `Invalid time range: start time (${startMs}ms) must be before end time (${endMs}ms)`\n    );\n  }\n\n  try {\n    // Create a true synthetic snapshot at the exact trim start point\n    console.log(\n      `Creating synthetic snapshot at trim start point (${startMs}ms)...`\n    );\n\n    // First, try the simple approach - check if we have a snapshot close enough\n    const snapshots = events.filter((e) => e.type === 2);\n    const closeSnapshot = snapshots.find(\n      (s) => Math.abs(s.timestamp - startMs) < 1000 // Within 1 second\n    );\n\n    let syntheticSnapshot;\n    if (closeSnapshot && closeSnapshot.timestamp === startMs) {\n      // Perfect match - use it directly\n      console.log(`Found exact snapshot at trim point`);\n      syntheticSnapshot = closeSnapshot;\n    } else {\n      // Need to create synthetic snapshot\n      syntheticSnapshot = await createTrueSyntheticSnapshot(events, startMs);\n      console.log(`Synthetic snapshot created successfully`);\n    }\n\n    // Build the new events array starting at 0\n    const newEvents = [];\n\n    // Get original meta event for viewport info\n    const originalMeta = events.find((e) => e.type === 4);\n\n    // Create meta event at timestamp 0\n    const metaEvent = {\n      type: 4, // Meta\n      data: {\n        href: originalMeta?.data?.href || window.location.href,\n        width: originalMeta?.data?.width || 1920,\n        height: originalMeta?.data?.height || 1080,\n      },\n      timestamp: 0,\n    };\n\n    // Add tabId if present\n    if (syntheticSnapshot.tabId !== undefined) {\n      metaEvent.tabId = syntheticSnapshot.tabId;\n    }\n\n    newEvents.push(metaEvent);\n\n    // Add synthetic snapshot at timestamp 1\n    const adjustedSnapshot = {\n      ...syntheticSnapshot,\n      timestamp: 1,\n    };\n    newEvents.push(adjustedSnapshot);\n\n    // Include only events within the trim range, adjusting timestamps\n    const eventsInRange = events.filter((event) => {\n      return event.timestamp > startMs && event.timestamp <= endMs;\n    });\n\n    console.log(`Found ${eventsInRange.length} events within trim range`);\n\n    // Add all events in range with adjusted timestamps\n    for (const event of eventsInRange) {\n      const adjustedEvent = {\n        ...event,\n        timestamp: event.timestamp - startMs + 2, // Start after meta and snapshot\n      };\n      newEvents.push(adjustedEvent);\n    }\n\n    // Sort by timestamp (should already be in order)\n    newEvents.sort((a, b) => a.timestamp - b.timestamp);\n\n    console.log(`Original recording: ${events.length} events`);\n    console.log(`Trimmed recording: ${newEvents.length} events`);\n    console.log(`Trimmed duration: ${(endMs - startMs) / 1000} seconds`);\n\n    return newEvents;\n  } catch (error) {\n    console.error(\"Failed to create synthetic snapshot:\", error);\n\n    // Fallback to the old method if synthetic snapshot fails\n    console.log(\"Falling back to traditional trim method...\");\n    return trimRecordingFallback(events, startMs, endMs);\n  }\n}\n\n// Keep the old implementation as a fallback\nfunction trimRecordingFallback(events, startMs, endMs) {\n  // Find ALL full snapshots and choose the best one\n  const fullSnapshots = [];\n  for (let i = 0; i < events.length; i++) {\n    if (events[i].type === 2) {\n      fullSnapshots.push({ snapshot: events[i], index: i });\n    }\n  }\n\n  if (fullSnapshots.length === 0) {\n    throw new Error(\"No full snapshot found in recording\");\n  }\n\n  // Find the best snapshot - prefer one close to but before the start time\n  let baseSnapshot = null;\n  let baseSnapshotIndex = -1;\n\n  // First, look for snapshots within 30 seconds before the trim start\n  const threshold = 30000; // 30 seconds in milliseconds\n  for (const { snapshot, index } of fullSnapshots) {\n    if (\n      snapshot.timestamp <= startMs &&\n      snapshot.timestamp >= startMs - threshold\n    ) {\n      baseSnapshot = snapshot;\n      baseSnapshotIndex = index;\n    }\n  }\n\n  // If no snapshot within threshold, find the closest one before start\n  if (!baseSnapshot) {\n    for (const { snapshot, index } of fullSnapshots) {\n      if (snapshot.timestamp <= startMs) {\n        baseSnapshot = snapshot;\n        baseSnapshotIndex = index;\n      }\n    }\n  }\n\n  // If still no snapshot (trim starts before first snapshot), use the first one\n  if (!baseSnapshot) {\n    baseSnapshot = fullSnapshots[0].snapshot;\n    baseSnapshotIndex = fullSnapshots[0].index;\n  }\n\n  if (!baseSnapshot) {\n    throw new Error(\"No full snapshot found in recording\");\n  }\n\n  console.log(\n    `Using base snapshot at index ${baseSnapshotIndex}, timestamp ${baseSnapshot.timestamp}ms`\n  );\n  console.log(\n    `Time from base snapshot to trim start: ${\n      (startMs - baseSnapshot.timestamp) / 1000\n    } seconds`\n  );\n\n  // Build the new events array\n  const newEvents = [];\n\n  // Add the base snapshot\n  newEvents.push({\n    ...baseSnapshot,\n    timestamp: baseSnapshot.timestamp,\n  });\n\n  // Add meta event if we have one\n  const metaEvent = events.find((e) => e.type === 4);\n  if (metaEvent) {\n    newEvents.push({\n      ...metaEvent,\n      timestamp: baseSnapshot.timestamp + 1,\n    });\n  }\n\n  // Count events in different ranges for debugging\n  let eventsBeforeTrim = 0;\n  let eventsInTrim = 0;\n\n  // Include necessary events to reconstruct DOM state at startMs\n  // and all events within the trim range\n  for (let i = baseSnapshotIndex + 1; i < events.length; i++) {\n    const event = events[i];\n\n    // Stop if we've passed the end time\n    if (event.timestamp > endMs) {\n      break;\n    }\n\n    // Skip full snapshots - we already have our base\n    if (event.type === 2) {\n      continue;\n    }\n\n    // For events before the trim start, only include mutations\n    // that are necessary for DOM reconstruction\n    if (event.timestamp < startMs) {\n      // Only include incremental snapshots (mutations)\n      if (event.type === 3 && event.data && event.data.source === 0) {\n        newEvents.push(event);\n        eventsBeforeTrim++;\n      }\n    } else {\n      // Include all events within the trim range\n      newEvents.push(event);\n      eventsInTrim++;\n    }\n  }\n\n  console.log(`Events included before trim start: ${eventsBeforeTrim}`);\n  console.log(`Events included within trim range: ${eventsInTrim}`);\n\n  // Sort by timestamp to ensure proper order\n  newEvents.sort((a, b) => a.timestamp - b.timestamp);\n\n  // If we need at least 2 events and only have 1, add a minimal event\n  if (newEvents.length === 1) {\n    console.log(\"Only one event found, adding minimal event\");\n    newEvents.push({\n      type: 3, // IncrementalSnapshot\n      data: {\n        source: 0, // Mutation\n        texts: [],\n        attributes: [],\n        removes: [],\n        adds: [],\n      },\n      timestamp: baseSnapshot.timestamp + 10,\n    });\n  }\n\n  // Shift timestamps so playback starts at the trim point\n  const timeShift = startMs - baseSnapshot.timestamp;\n  const baseTime = newEvents[0].timestamp;\n\n  console.log(`Time shift: ${timeShift / 1000} seconds`);\n  console.log(`Adjusting timestamps to start playback at trim point...`);\n\n  // Adjust all timestamps\n  const shiftedEvents = newEvents.map((event, index) => {\n    // Calculate relative time from base\n    const relativeTime = event.timestamp - baseTime;\n\n    // For events before the trim start, compress them into the first 100ms\n    if (\n      event.timestamp < startMs &&\n      event.type === 3 &&\n      event.data.source === 0\n    ) {\n      // Compress pre-trim mutations into first 100ms\n      const compressionRatio = Math.min(relativeTime / timeShift, 1);\n      return {\n        ...event,\n        timestamp: compressionRatio * 100,\n      };\n    } else {\n      // For events at or after trim start, maintain relative timing\n      const newTimestamp = event.timestamp - startMs + 100;\n      return {\n        ...event,\n        timestamp: newTimestamp,\n      };\n    }\n  });\n\n  console.log(`Original recording: ${events.length} events`);\n  console.log(`Trimmed recording: ${shiftedEvents.length} events`);\n\n  // Validate we have at least 2 events\n  if (shiftedEvents.length < 2) {\n    throw new Error(\n      `Trimmed recording has only ${shiftedEvents.length} events, need at least 2`\n    );\n  }\n\n  return shiftedEvents;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}